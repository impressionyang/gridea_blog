{"posts":[{"title":"使用picocm来进行Linux下的串口调试","content":"先导 为什么不用minicom呢？功能又强大由好用不是。主要原因就是minicom没有彩色文字，看着难受，特别是调试ARM Linux的时候233 安装 因为正常是在Debian系列的Linux发行版上面使用的(deepin或者ubuntu这些的，解决方案比较完善)，所以就是用apt来进行安装，其他发行版使用自己的包管理软件进行安装 sudo apt install picocom -y 连接调试设备 连接前准备 首先要确定是接入的设备 dmesg | grep ttyUSB 然后使得这个设备能被picocom工具访问使用 sudo chmod 777 /dev/ttyUSBx 请自行将ttyUSBx替换为当前使用的串口设备 连接串口设备 下面是一般连接一个串口设备说使用的命令 picocom -b 115200 /dev/ttyUSBx 参数讲解 -b: 设置波特率参数 /dev/ttyUSBx:串口设备，请替换为当前使用的串口设备 打开帮助提示页面 按动Ctrl a+h就可以弹出帮助页面，里面有相关的命令提示可以做什么，需要注意的一点是，里面的命令提示都是说C-x什么的，其实C-就是由Ctrl+a转义过来的，正如帮助页面的C-h，就是用Ctrl a+h打开的，所以其他的命令也是同理 发送接收文件 如果直接使用上面的连接串口设备的命令直接去进行文件发送的话，你就会发现Ctrl a+s进行发送的时候根本没办法确定使用哪种协议进行的，很让人摸不着头脑(其实默认的传输发送接收模式之前的连接截图已经有曝光了，就是z模式233)，其实只要仔细点去阅读picocom的man文档的话就能够看到相关的发送接收小节里面有提及相关的内容 所以，确定好想使用何种方式进行传输之后就可以使用相应的命令去打开picocom了 例如使用ymode进行发送接收的例子 picocom --send-cmd &quot;sb -vv&quot; --receive-cmd &quot;rb -vv&quot; -b 115200 /dev/ttyUSBx 同样的，使用当前的串口设备文件 退出picocom 直接就是按动Ctrl a+q就可以 尾声 picocom相较于minicom功能性来说，还是有那么一点欠缺的，但是picocom毕竟颜值高呀，在这个看脸的时代，picocom难道不是最佳选择吗233[手动狗头] impressionyang ","link":"https://impressionyang.vercel.app/post/picocom-dialy-use/"},{"title":"Linux下在文件夹所有文件中查找相关内容","content":"先导 本文是为了记录在编程中进行一些在文件夹中查找某些关键字进行配置时查找文件过于麻烦的解决办法 在Linux开发中使用一些命令或者命令的配合进行查找文件内容及匹配关键词还是比较方便的。 使用grep grep是在使用Linux时经常会用到的一个命令了，这个命令平时大都主要用来进行对一段输出的关键字定位，但是这个命令也可以通过使用某些参数来达到文件夹文件内容遍历的效果 命令原型 grep -nr &quot;str&quot; path 参数说明 grep: 就是grep命令 -nr: n是line number行号，r是recursive，可以理解为遍历文件文件夹 &quot;str&quot;: 双引号里面的str就是要查找的内容，用双引号何以使用空格和一些字符进行查找 path: path就是查找路径，默认是./，也就是当前目录开始，也可以手动指定目录 实例 grep -nr &quot;/bin/bash&quot; /home/$USER 优缺点 优点：命令简单方便，简短 缺点：会遍历所有文件，效率较低 使用find、xargs和grep配合 find是查找指令，用来查找文件的；xargs可以将标准输入作为另一个命令的参数；grep上面已经解释过了。那么，如果使用find来循环查找文件，使用他输出的文件名作为参数给xargs，xargs再将文件名作为grep的参数输入，使用grep来查找文件内容进行定位不久可以实现文件内容查找了吗 命令原型 find path -name &quot;PATTEN&quot; | xargs grep -n &quot;str&quot; | grep &quot;str&quot; 参数说明 find、xargs、grep：上面已经讲过，分别是三个软件 name：就是通过名字查找，后面跟着的参数可以通过正则表达式类似的方法限定文件名 其他grep或者类似的参数据不赘述了 实例 find /home/$USER/.config -name &quot;*.sh&quot; | xargs grep &quot;/bin/bash&quot; | grep &quot;/bin/bash&quot; 优缺点 优点：可以通过-name来限定文件名，从而减少grep查看文件内容的次数，提高效率 缺点：命令冗长，难记 后记 关于这两种方法的取舍其实还是看日常使用过程，如果文件夹内的文件较少，可以使用第一种方法，方便快捷；但是如果文件很多的情况下为了节省查找时间，可以使用第二种方法，能够较为快速地查找到想要的内容。 impressionyang","link":"https://impressionyang.vercel.app/post/search-content-in-files-of-dir/"},{"title":"Linux解压缩文件","content":" 先导：写这篇文章是为了记录在Linux下常用的、简单的进行压缩文件的解压缩以及打包压缩文件的方法，以方便自己未来忘记了在查询 全局说明 下面的两个参数意义 dest：目标文件，压缩的话将dest换成你想要的文件名 src：来源文件，是一个文件或者一个文件夹，压缩要想打包多个就空格后追加接下来的文件或者文件夹，解压的就不行了 tar.gz 总的来说这是两种格式的压缩文件，tar是归档文件，gz是压缩文件，tar.gz是一种Linux下常用的压缩文件格式，一般的源代码包都是使用这种压缩文件的 打包压缩 将文件或者文件夹打包压缩成tar.gz tar -czvf dest.tar.gz src 解压缩 tar -xzvf src.tar.gz 说明 参数czxvf说明如下： -c: create,创建一个归档 -z: gzip、gunzip,gun的开放式压缩文档？ -x: extract,将文件从归档中提取出来 -v: verbose,详细的将文件列表信息打印出来 -f: file,从归档文件中操作 tar.bz2 这个压缩文件格式和上一个差不多，也是先归档，然后才压缩一种压缩文件，不同的是压缩工具是bzip2。所以基本操作是一样的，只不过是压缩工具的参数换成-j就行了 打包压缩 tar -cjvf dest.tar.bz2 src 解压缩 tar -xjvf src.tar.bz2 rar 压缩打包 rar a dest.rar src 解压缩 unrar e src.rar 参数说明 a: archive，添加文件至归档 e: extract, 将文件解压到当前位置 zip 压缩打包 zip -r dest.rar src 解压缩 unzip -o src.rar 参数说明 r: query，递归操作，子目录也打包 o: override, 覆盖解压缩 gzip 压缩打包 gzip -c src &gt;dest.gz 解压缩 gunzip -c src.gz &gt;dest 参数说明 c: 保留原文件 bzip2 压缩打包 bzip2 -k src 运行后会在当前目录生成对应文件的压缩包，自动命名 解压缩 bzip2 -kd src.bz2 参数说明 k: keep, 保留原文件 d: decompress, 解压缩 impressionyang","link":"https://impressionyang.vercel.app/post/compress-file-extract-and-compress/"},{"title":"C语言二级指针用法之模拟句柄用途","content":"先导 因为在学习中使用到了二级指针进行操作，故而作此总结 提前了解 句柄 以下词条来自百度百科 句柄（Handle）是一个是用来标识对象或者项目的标识符，可以用来描述窗体、文件等，值得注意的是句柄不能是常量 。 Windows之所以要设立句柄，根本上源于内存管理机制的问题，即虚拟地址。简而言之数据的地址需要变动，变动以后就需要有人来记录、管理变动，因此系统用句柄来记载数据地址的变更。在程序设计中，句柄是一种特殊的智能指针，当一个应用程序要引用其他系统（如数据库、操作系统）所管理的内存块或对象时，就要使用句柄 。 二级指针 指针是C语言中最高深莫测的部分了，能够直接操作内存的这些指针如果使用得当的话可以完成很多很高效的代码。而二级或者多级指针则能够达到你之前想都不敢想的效果。 以下来自于百度百科 A(即B的地址)是指向指针的指针，称为二级指针，用于存放二级指针的变量称为二级指针变量．根据B的不同情况，二级指针又分为指向指针变量的指针和指向数组的指针。 提出需求 这次总结的内容则是将指针当做句柄放进函数当形参是动态地申请空间来用作其他用途的。 首先，我们要知道，我们如果直接把指针变量的地址当做函数的实参，去在函数里面申请空间，由于形参定义是一级指针，是无法拿到动态申请的空间的，以下就是一个实例 #include &lt;stdio.h&gt; static void get_space(int* p) { p = (int *)malloc(sizeof(int)); *p = 16; } int main() { int a = 10; int* pa = &amp;a; printf(&quot;*pa=%d \\t pa=%p \\n&quot;, *pa, pa); get_space(&amp;pa); printf(&quot;*pa=%d \\t pa=%p \\n&quot;, *pa, pa); get_space(pa); printf(&quot;*pa=%d \\t pa=%p \\n&quot;, *pa, pa); return 0; } 运行得到以下结果 显然，这个结果正和上面所说的，在main函数传进去的实参，无论是指针变量还是地址，在函数里面的操作并不能通过一级指针的形参返回动态申请的空间，这样做很容易出现野指针现象。 原因其实很简单，在形参定义的一级指针变量只是有从实参传递过来的地址而已，无论是指针变量内的地址还是指针变量本身的地址，只是存在形参一级指针变量当中，正如上面表现的，不管指针变量p的内容是pa或者pa的地址，只要使用p去获取空间的地址，便会使得指针p的内容从pa或者pa的地址变成新空间的地址，而在main函数中的pa并没有被影响到。 注意：上面的情况不要尝试用*p配合实参是pa的地址来接受新空间，会造成段错误，因为那样就是用一个int型的变量去接受一个int*型的值了 那么，如果我想通过指针去在函数中获取动态的空间要如何操作 解决方案 其实通过上面的注意事项已经有一点眉目了，要想使用*符号来提取地址内容的方法来获得修改主函数传递的指针变量的内容权限的原理就是使得*p能够代表一个地址。由此可见，指针的指针那就是二级指针了，表现在代码中就是将上述的形参定义为二级指针并使用主函数的一级指针变量去传递参数。 #include &lt;stdio.h&gt; static void get_space(int** p) { *p = (int *)malloc(sizeof(int)); int* temp = *p; *temp = 66; } int main() { int a = 10; int* pa = &amp;a; printf(&quot;*pa=%d \\t pa=%p \\n&quot;, *pa, pa); get_space(&amp;pa); printf(&quot;*pa=%d \\t pa=%p \\n&quot;, *pa, pa); return 0; } 运行得到以下结果： 由此便能通过一个指针在函数中去动态申请空间并返回上一层中了。 应用场景 光是看上面的例子并不能了解这种方法的强大之处，但是模仿上面所说的句柄的思想，来举例说说这个方案的好处吧。 首先假设，你负责一个项目的某个模块的编写，需要编写出测试app，模块实现以及该模块所需的协议，并且为了减少各个方法与模块之间的耦合性以及代码的简洁效率等因素不允许大量使用全局变量，但是你要完成这个模块有需要很多的变量来存储一些参数以供该模块实现内的各个方法进行调用，这时候要怎么解决呢？ 结构体是解决这种变量多的一种方案，但是如果在模块内使用全局变量的话你又如何管理这些空间呢（如果里面有较大的空间占用），只能等程序结束时清除吗 这时候使用一个指针变量来保存一个动态空间的地址来进行操作显然更方便，也就是使用一个void*型指针变量来存储地址，在模块初始化时申请空间，模块进行功能时将地址下放，用完后动态地清理该空间。而这个void*型的指针就是本次提出的句柄的模仿。 光是空口说出有点不太好说明该方案的可行性，下面用一个小例子来证明： 假设下面的主函数函数和其他函数不在同一文件中 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct couple_num { int a; char b; } couple_num_t; void get_space(void** a) { printf(&quot;*a addr:%p\\n&quot;, *a); *a = (couple_num_t *) malloc (sizeof(couple_num_t)); printf(&quot;%p\\n&quot;, a); couple_num_t *p = *a; p-&gt;a = 1000; p-&gt;b = 'r'; } void show(void *a) { printf(&quot;*a addr:%p\\n&quot;, a); couple_num_t* temp = a; printf(&quot;show:\\n%d\\n%c\\n&quot;,temp-&gt;a, temp-&gt;b); } void release(void** a) { free(*a); } int main() { void *p = NULL; printf(&quot;origin p addr:%p\\n&quot;, p); get_space(&amp;p); printf(&quot;after change p addr:%p\\n&quot;, p); couple_num_t* temp = p; printf(&quot;temp:%d\\n&quot;,temp-&gt;a); show(p); release(&amp;p); printf(&quot;after release p addr：%p\\n&quot;, p); show(p); getchar(); return 0; } 运行结果如下： 可以看到，使用这种方法，不用在主函数暴露结构体内容，也能够将结构体的地址空间进行掌握，高效的利用了指针的特性完成功能，使得各个方法之间相互影响减少，参数传递也简单，并且在使用完成后还能动态清除空间。 后记 这种方法在C语言下设计功能模块时特别有用，模仿了面向对象的句柄思想，减少模块间的耦合（不使用全局变量，各方法就不会无意间相互干扰了）。 impressionyang ","link":"https://impressionyang.vercel.app/post/pointer-level2-as-handle/"},{"title":"给pugjs的stun主题添加canvas时钟","content":"先导 首先隔了这么久才继续进行更新的原因是网站备案和毕业设计，加上刚入职没有时间去进行内容更新，以后会继续更新了 在pugjs中添加一些好用的东西这个系列会长期的添加更新，因为这些都是会用在博客当中的，而且这些操作都比较简单，都是在主题的相应文件位置添加相应代码即可。 内容介绍 这次添加的内容是在右边栏那里加上一个时钟，用来给阅读的人直观地看到时间，时钟的代码是直接从网上拷贝下来的，并且自己做了修改，地址是这里,打开这个链接就能看到一个时钟，此时检查页面元素定位到时钟所在的div标签，其中有一个canvas标签，将其复制下来，并且找到下面与之最近的script标签查看到时钟的逻辑代码，也将其复制下来进行修改后就差不多可以使用了。 首先声明，代码是直接复制的，复制也没有删除，主要是为了学习用途，如果造成侵权或者修改了不应修改的地方，还请拿出版权证据证明后修改或者删除您的代码，自行复制后造成的一切问题与我无关 脚本代码 原脚本 复制下来的脚本内容大致如下，内容有点多请别介意，方便复制 &lt;canvas id=&quot;clock&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; var time = new Date(); var h = time.getHours(); //时 var m = time.getMinutes(); //分 var s = time.getSeconds(); //秒 h=h&gt;12?(h-12)*5+parseInt(m/12):h*5+parseInt(m/12); //时针 初始位置 //===================================== var x=200,y=200,sAngle=0; //x y 原点 秒针角度变量 function draw(){ var c=document.getElementById(&quot;clock&quot;); var ctx=c.getContext(&quot;2d&quot;); //获取绘图对象 ctx.clearRect(0,0,c.width,c.height); //清除上次绘制的图形 s++;//秒针 ctx.fillStyle = '#fff' //填充白色背景色 ctx.fillRect(0,0,c.width,c.height); //设置画布区域 //填充圆点，在画布中心（200,200）绘制一个半径10px的圆形 ctx.beginPath(); ctx.arc(x,y,10,0,Math.PI*2,true); ctx.fill(); ctx.closePath(); //填充版权文字 ctx.fillStyle=&quot;#ccc&quot;; ctx.font = &quot;12pt Arial&quot;; ctx.fillText(&quot;Helloweba.com&quot;,150,250); //调用日期并填充到画布中 ctx.fillStyle=&quot;#666&quot;; ctx.font = &quot;14pt Verdana&quot;; ctx.fillText(time.getMonth()+1+&quot;-&quot;+time.getDate(),183,170); ctx.save(); //保存当前绘图状态 // 时间刻度 for(var i=0;i&lt;12;i++){ var angle=(Math.PI*2)/12; ctx.beginPath();//开始绘制 ctx.font=&quot;12px Arial&quot;; if(i==0||i==3||i==6||i==9){ ctx.fillStyle=&quot;red&quot;; radius=4; }else{ ctx.fillStyle=&quot;blue&quot;; radius=3; } ctx.arc(x,y-100,radius,0,Math.PI*2,true); //画圆 ctx.fill(); //填充路径 trans(ctx,x,y,angle); //刻度分布 } ctx.restore(); //恢复上次保存的绘图状态 sAngle=(Math.PI*2)/60*s; //秒度 //时针转动 ctx.save(); ctx.strokeStyle=&quot;red&quot;; ctx.lineWidth=3; trans(ctx,x,y,(Math.PI*2)/60*h); pointer(ctx,x,y,y-40); ctx.restore(); //分针转动 ctx.save(); ctx.strokeStyle=&quot;blue&quot;; ctx.lineWidth=2; trans(ctx,x,y,(Math.PI*2)/60*m); pointer(ctx,x,y,y-68); ctx.restore(); //秒针转动 ctx.save(); ctx.strokeStyle=&quot;#000&quot;; trans(ctx,x,y,sAngle); pointer(ctx,x,y,y-80); ctx.restore(); //数据整理 if(s%60==0){ sAngle=0,s=0,m++; if(m%12==0){ //每十二分 时针旋转一次 if(m!=0)h++; if(m%60==0)m=0; } if(h%60==0)h=0; } } //绘制指针 function pointer(ctx,x,y,z){ ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x,z); ctx.stroke(); ctx.fill(); } //据坐标旋转 function trans(ctx,x,y,angle){ ctx.transform(Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), x*(1-Math.cos(angle)) + x*Math.sin(angle), y*(1-Math.cos(angle)) - y*Math.sin(angle)) } setInterval(&quot;draw()&quot;,1000); &lt;/script&gt; 修改后的脚本 下面是修改后用之前的网站进行转换成pugjs的脚本，懒一点的就直接复制下面代码吧 br div(style='position: relative;top: 0px;left: 0px;') canvas#clock(width='250', height='250') script. var time = new Date(); var h = time.getHours(); //时 var m = time.getMinutes(); //分 var s = time.getSeconds(); //秒 h = h &gt; 12 ? (h - 12) * 5 + parseInt(m / 12) : h * 5 + parseInt(m / 12); //时针 初始位置 //===================================== var cc = document.getElementById(&quot;clock&quot;); var x = cc.width/2.0, y = cc.height/2.0, sAngle = 0; //x y 原点 秒针角度变量 function draw() { var c = document.getElementById(&quot;clock&quot;); var ctx = c.getContext(&quot;2d&quot;); //获取绘图对象 ctx.clearRect(0, 0, c.width, c.height); //清除上次绘制的图形 s++;//秒针 ctx.fillStyle = '#fff' //填充白色背景色 ctx.fillRect(0, 0, c.width, c.height); //设置画布区域 //填充圆点，在画布中心（200,200）绘制一个半径10px的圆形 ctx.beginPath(); ctx.arc(x, y, 10, 0, Math.PI * 2, true); ctx.fill(); ctx.closePath(); //填充版权文字 ctx.fillStyle = &quot;#ccc&quot;; ctx.font = &quot;12pt Arial&quot;; // ctx.fillText(&quot;impressionyang.top&quot;, 10, c.height-10); //调用日期并填充到画布中 ctx.fillStyle = &quot;#666&quot;; ctx.font = &quot;14pt Verdana&quot;; ctx.fillText(time.getMonth() + 1 + &quot;-&quot; + time.getDate(), c.width/2, c.height/2); ctx.save(); //保存当前绘图状态 // 时间刻度 for (var i = 0; i &lt; 12; i++) { var angle = (Math.PI * 2) / 12; ctx.beginPath();//开始绘制 ctx.font = &quot;12px Arial&quot;; if (i == 0 || i == 3 || i == 6 || i == 9) { ctx.fillStyle = &quot;red&quot;; radius = 4; } else { ctx.fillStyle = &quot;blue&quot;; radius = 3; } ctx.arc(x, y - 100, radius, 0, Math.PI * 2, true); //画圆 ctx.fill(); //填充路径 trans(ctx, x, y, angle); //刻度分布 } ctx.restore(); //恢复上次保存的绘图状态 sAngle = (Math.PI * 2) / 60 * s; //秒度 //时针转动 ctx.save(); ctx.strokeStyle = &quot;red&quot;; ctx.lineWidth = 3; trans(ctx, x, y, (Math.PI * 2) / 60 * h); pointer(ctx, x, y, y - 40); ctx.restore(); //分针转动 ctx.save(); ctx.strokeStyle = &quot;blue&quot;; ctx.lineWidth = 2; trans(ctx, x, y, (Math.PI * 2) / 60 * m); pointer(ctx, x, y, y - 68); ctx.restore(); //秒针转动 ctx.save(); ctx.strokeStyle = &quot;#000&quot;; trans(ctx, x, y, sAngle); pointer(ctx, x, y, y - 80); ctx.restore(); //数据整理 if (s % 60 == 0) { sAngle = 0, s = 0, m++; if (m % 12 == 0) { //每十二分 时针旋转一次 if (m != 0) h++; if (m % 60 == 0) m = 0; } if (h % 60 == 0) h = 0; } } //绘制指针 function pointer(ctx, x, y, z) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, z); ctx.stroke(); ctx.fill(); } //据坐标旋转 function trans(ctx, x, y, angle) { ctx.transform(Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), x * (1 - Math.cos(angle)) + x * Math.sin(angle), y * (1 - Math.cos(angle)) - y * Math.sin(angle)) } setInterval(&quot;draw()&quot;, 1000); 至此就能够添加这个时钟到网站里面了，是不是感觉很简单呢。 后记 虽然觉得直接拉取被人的东西有点不太厚道，但是我可是最强缝合怪啊，想拿来凑一凑再说哈哈哈。 impressionyang ","link":"https://impressionyang.vercel.app/post/add-canvas-clock-in-pugjs/"},{"title":"最近网站备案中。。。","content":"说明 打算是主要打理国内的空间，当然github也会同步发布，是所以使用未备案的域名感觉还是挺不妥当的，还是备案一下，但是我万万没想到的是备案有那么多需要注意的问题 博客现有问题 现在博客的一些相关功能已经被我暂停了,后面慢慢恢复 原来的域名无法访问，除非使用pages的二级域名impressionyang.github.io、impressionyang.gitee.io 备案历程[还未备案成功] 先是在阿里云进行备案，然后发现要使用他们的实例来备案，然后备案的流程好事太长，最终卡在了使用复印件提交管局的步骤，不耐烦然后放弃了，因为还要申请阿里云的幕布 现在在西部数码进行电子化备案，但是因为网站名称退回了一次，但是他们的处理速度挺快，所以在继续备案 后记 原来以为备案网站很简单，原来还是太年轻了，以后打算使用西部数码的虚拟主机+GitHub Pages+Gitee Pages三方面进行文章的发布了 祝我顺利 impressionyang ","link":"https://impressionyang.vercel.app/post/the-blog-is-put-on-record/"},{"title":"Arch Linux切换rEFInd开机引导程序","content":"先导 以下rEFInd的arckwiki词条的内容： rEFInd 是一个 UEFI 启动管理器。它是 rEFIt （不再维护）的一个分支并且针对非 Mac 硬件修复了若干问题。它被设计为平台无关，可启动多个操作系统。 使用rEFInd的需求是我原来使用的是bootctl这个启动引导程序,虽然简单好用,但是只有黑白界面难免有点单调,所以就想使用一个比较漂亮的但是文件结构又简洁的bootloader,所以grub就被丢弃了,虽然它的却很强大,但是文件结构有点复杂,配置影响因素有点多 安装rEFInd sudo pacman -S refind-efi 配置 备份原有引导 首先备份移除原有的bootloader,我之前用的是bootctl,所以需要备份/boot/loader文件夹和/boot/EFI/systemd/systemd-bootx64.efi文件 cp -r /boot/loader ~/loader cp -r /boot/EFI/systemd ~/systemd 配置rEFInd 安装rEFInd引导文件至启动分区: sudo refind-install 一般情况下能够直接进行安装,如果出问题请查看archwiki的rEFInd的手动安装引导文件小节,请点击这里 配置主题 rEFInd的主题可以在github中自己搜索得到 将自己心仪的主题下载下来之后将其解压至/boot/refind/themes中,在/boot/refind/refind.conf的末尾加入include themes/你下载的主题/theme.conf即可生效. 配置自定义启动项 编辑文件/boot/EFI/refind/refind.conf中向下滑差不多到3/4位置的位置中的Arch Linux小节,将其中的文件配置成自己的启动方式,下面的例子是我的 menuentry &quot;Arch Linux&quot; { icon /EFI/refind/themes/refind-ambience/icons/os_arch.png #volume &quot;Arch Linux&quot; loader /vmlinuz-linux initrd /amd-ucode.img initrd /initramfs-linux.img options &quot;root=PARTUUID=7ce1b087-1f97-4a98-ac50-408353207b92 rw&quot; submenuentry &quot;Boot using fallback initramfs&quot; { initrd /initramfs-linux-fallback.img } submenuentry &quot;Boot to terminal&quot; { add_options &quot;systemd.unit=multi-user.target&quot; } #disabled } 可以看到的的启动的icon是使用主题里面提供的,可以使得启动的界面更加统一 后记 rEFInd启动引导程序还是很秀的,主题也挺美观,下面放一张效果图(虚拟机中的) impressionyang ","link":"https://impressionyang.vercel.app/post/arch-refind-bootloader-efi/"},{"title":"Qt文件操作QFile","content":"先导 因为有需求使用Qt的文件I/O操作,所以做此记录以供后用 使用 简单使用以及说明 简单的使用基本上分4步: 定义文件变量 打开文件 执行文件I/O操作 关闭文件 简单使用读取文件: QFile file(&quot;your file path&quot;); file.open(QFile::ReadOnly); QByteArray buf; while(file.read(buf.data(),1024)&gt;0){ cout&lt;&lt;buf; buf.clear(); } file.close(); 上述文件读取操作中,使用的是C++习惯下的read函数,其使用也和C++的read函数差不多,需要讲解一下的是QFile的open函数的参数,有以下的表列 参数 说明 NotOpen 不打开文件 ReadOnly 只读 WriteOnly 只写 ReadWrite 可读写 Append 追加 Truncate 尽可能在打开文件前删除 Text 限定文本操作,读文件的话结束符翻译为文本的\\n,写文件则结尾时写入当前系统的文本结束符,例如win的\\n\\r Unbuffered 不能使用缓存流I/O NewOnly 在创建文件的时候确保文件是不存在的,不然文件不能打开 ExistingOnly 在读取文件是确保文件是存在的,不然文件不能打开 简单写入文件 QFile file(&quot;your file path&quot;); file.open(QFile::WriteOnly | QFile::Truncate); QByteArray buf(&quot;text to write&quot;); file.write(buf); file.close(); 使用stream进行读写 使用stream进行读写时可以使用输入(&gt;&gt;)输出(&lt;&lt;)流符号进行格式化输入输出,读写方便,在Qt的文件I/O中可以使用QTextStream和QDateStream来对文件进行操作 读取文件: QFile file(&quot;in.txt&quot;); if (!file.open(QFile::ReadOnly | QFile::Text)) return; QByteArray buf; QTextStream in(&amp;file); while (!in.atEnd()) { in&gt;&gt;buf.data(); cout&lt;&lt;buf; buf.clear(); } file.close(); 写入文件: QFile file(&quot;out.txt&quot;); if (!file.open(QFile::WriteOnly | QFile::Text)) return; QTextStream out(&amp;file); out &lt;&lt; &quot;a=&quot; &lt;&lt; 1 &lt;&lt; &quot;\\n&quot;; out.flush(); file.close(); 后记 Qt的文件操作对于一个应用软件来说是一个重要的使用方式,虽然上面讲述了Qt文件I/O的基本操作,但是其使用方式还有很多,这仅仅是最基本的使用方式而已,以后还有很多东西需要学习的 impressionyang ","link":"https://impressionyang.vercel.app/post/qt-qfile-note/"},{"title":"Qt UDP广播","content":"先导 最近有使用QT的UDP广播,所以记录这篇帖子记录一下 讲解 什么是UDP广播,我就不搬百科的内容了,就按照我的一点理解来说吧 UDP是一种网络进程间通信的技术,一般和TCP一起出现,UDP的通信优势是速度快、不需要确定对方IP地址，但是缺点是连接不可靠。而UDP广播是UDP下的一种通讯手段，他作为广播发送端（使用writeDatagram()方法）时可以在当前网络下的广播地址中进行发送广播信息，而任何接收端(使用readDatagram()方法)都能接收到服务器当前发送的广播信息 代码实例 只写出关键的代码，完整带图形界面的测试项目已经上传至我的github 发送端 UdpBrocastServer::UdpBrocastServer(QString msg) { brocast_server = new QUdpSocket(); if (!msg.isEmpty()) { brocast_server-&gt;writeDatagram(msg.toLocal8Bit(), QHostAddress::Broadcast, 10086); } else { qDebug() &lt;&lt; &quot;brocast server: msg is empty!&quot;; } } 接收端 UdpBrocastClient::UdpBrocastClient() { brocast_client = new QUdpSocket(); brocast_client-&gt;bind(10086, QUdpSocket::ShareAddress); QObject::connect(brocast_client, &amp;QUdpSocket::readyRead, this, [=]() { // QByteArray datagram; datagram.resize(brocast_client-&gt;pendingDatagramSize()); brocast_client-&gt;readDatagram(datagram.data(), datagram.size()); emit getBrocastMsg(QString(datagram)); }); } 测试 带图形界面的测试 impressionyang ","link":"https://impressionyang.vercel.app/post/qt-udp-brocast/"},{"title":"为主题用pugjs编写的hexo博客添加网站运行时间","content":"先导 写这篇帖子的原因是我很想在博客网站下面添加网站的运行时间,网上虽然有教程是怎么添加的,但是他们演示的主题大都是用ejs或者是wig来编写的,而我使用的这个个人很喜欢的stun主题却是用pugjs编写的,实在是很想用,所以根据语法的转换规则修改了一份pug文件下添加的脚本来使用,美滋滋 脚本 语法参考的话可以去这里 原来的ejs脚本 &lt;div&gt; &lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt; &lt;script&gt; var now = new Date(); function createtime() { var grt= new Date(&quot;08/13/2018 00:00:00&quot;); now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 ){hnum = &quot;0&quot; + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = &quot;0&quot; + mnum;} seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 ){snum = &quot;0&quot; + snum;} document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; } setInterval(&quot;createtime()&quot;,250); &lt;/script&gt; &lt;/div&gt; 转换后的pugjs脚本 div span#timeDate 载入天数... span#times 载入时分秒... script. var now = new Date(); function createtime() { var grt= new Date(&quot;08/13/2018 00:00:00&quot;); now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 ){hnum = &quot;0&quot; + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = &quot;0&quot; + mnum;} seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 ){snum = &quot;0&quot; + snum;} document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; } setInterval(&quot;createtime()&quot;,250); 然后把上述脚本添加到主题的layout/_partials/footer/footer.pug文件中(不同主题可能文件不一样,请自行参考)即可在网页底部显示网站运行时间了OvO,不过要注意修改一下var grt= new Date(&quot;08/13/2018 00:00:00&quot;);中的起始时间哦! 效果 后记 后来发现了一个神奇的网站可以帮助从html转到pug,请戳这里,难受,虽然上面的不难翻译,但是用这个网站不费力是真的.... impressionyang ","link":"https://impressionyang.vercel.app/post/add-runing-time-in-pug-script-for-hexo/"},{"title":"archlinux安装篇（三） KDE配套小工具","content":"先导 经过上一次的在配置之后能够使用图形界面了,但是会发现有一些功能是使用不了的,包括一切笔记本上的快捷键,原因是缺少了相配套的小工具进行配置,本期就是讲讲这些相关配置的 再更新中... 电池及屏幕亮度 刚安装好KDE桌面没有安装电源相关组件,导致电源以及与之相关的亮度功能受到影响,需要安装相关的工具 sudo pacman -S acpid tlp powerdevil 安装好相关组件之后重启应该就能看到相关的功能可以使用了 声音托盘工具 刚安装好KDE桌面没有安装声音工具是不能调节声音的,除非使用外部功放设备,安装可选的工具有两个 一个是kmix,能够提供声音调节、选择播放设备和调整输入设备等功能,但是有一个缺点就是UI有点不太好看 sudo pacman -S kmix 另一个就是plasma-pa,看这个名字就知道这个是直接配合Plasma使用的 sudo pacman -S plasma-pa 蓝牙托盘工具以及蓝牙功能 蓝牙功能也是不经配置的话会有几率不能直接使用的,安装之后还需要进行配置使得蓝牙服务能够开机自启 sudo pacman -S bluez bluez-utils bluedevil 配置开机启动: sudo systemctl enable bluetooth 编辑配置 配置好开机自启动配置 编辑/etc/bluetooth/main.conf，使用vim工具sudo vim /etc/bluetooth/main.conf 在[Policy]下添加项目AutoEnable=true 配置蓝牙耳机相关 编辑/etc/pulse/system.pa，使用vim工具sudo vim /etc/pulse/system.pa,当然使用图形文本编辑工具也可以 在文中插入以下项目 load-module module-bluetooth-policy load-module module-bluetooth-discover 多屏功能 多屏输出这个功能的缺失是最近发现的,我使用的是X11+xrandr,需要安装一个能够图形配置xrandr的工具,找来找去也只在archwiki中找到了arandr这个图形界面工具. sudo pacman -S arandr 就可以通过这个工具配置图形输出了,只要通过输出-&gt;输出设备选择设备然后激活使用并在面板中拖放好相应位置皆即可 impressionyang ","link":"https://impressionyang.vercel.app/post/archlinux-install-3/"},{"title":"Markdown的时序图、流程图、和甘特图+Hexo的相关配置","content":"先导 本贴在手机端因为mermaid插件的问题显示会超出屏幕，以后在想办法解决，目前建议使用电脑浏览 持续更新中... 本贴是为了记录因为沦为需要进行时序图和流程图进行mermaid图像的学习而写下的 Hexo 相关配置 要想在Hexo中使用mermaid图形的话需要安装hexo-filter-mermaid-diagrams这个插件并且配置相关的设置，该插件是由作者Frank_Fang修改编写的，并且在他的github项目中给出了很详细的配置说明,本贴就节选我的配置来说明。 安装插件 cnpm install hexo-filter-mermaid-diagrams --save 配置插件 首先配置Hexo的_config.yml 需要在配置文件的文末添加 # mermaid chart mermaid: ## mermaid url https://github.com/knsv/mermaid enable: true # default true version: &quot;7.1.2&quot; # default v7.1.2 options: # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js #startOnload: true // default true 然后在配置主题的相关页面片段使得网页能够是别到插件生成的mermaid图并渲染(需要一定的时间,主要是配置的js源比较慢),因为的使用的主题stun的页面片段是用pug编写的,所以使用的是作者说明的配置来的,如果使用的是ejs或者其他文件编写的请查看作者的github是怎么说明的,根据作者推荐的配置是在在after_footer.pug文件里面,但是我的这个主题并没有这个文件,所以我选择直接使用footer.pug来进行配置,可能会比原来的慢一点... 于是,在主题/layout/footer/footer.pug里面添加以下内容 if theme.mermaid.enable == true script(type='text/javascript', id='maid-script' mermaidoptioins=theme.mermaid.options src='https://unpkg.com/mermaid@'+ theme.mermaid.version + '/dist/mermaid.min.js' + '?v=' + theme.version) script. if (window.mermaid) { var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins')); mermaid.initialize(options); } 至此,Hexo方面的配置基本完成,接下来就讲讲mermaid相关的语法 mermaid语法 mermaid的代码块标识是mermaid 创建一个代码块并将相关语句添加进去即可 如果想看到原汁原味的语法请到mermaid-js作者的git pages页面查看,里面有完整的语法支持,包括流程图、时序图、类图、活动土、甘特图和饼图，我这里只是节选一些我需要的进行简化抽取并进行简单的翻译 也可以体验mermaid-js作者提供的在线demo 流程图 程序流程图是用规定的符号描述一个专用程序中所需要的各项操作或判断的图示。这种流程图着重说明程序的逻辑性与处理顺序，具体描述了微机解题的逻辑及步骤。当程序中有较多循环语句和转移语句时，程序的结构将比较复杂，给程序设计与阅读造成困难。程序流程图用图的形式画出程序流向，是算法的一种图形化表示方法，具有直观、清晰、更易理解的特点。-百度百科&quot;程序流程图&quot; 程序流程图的mermaid语法基本如下: graph 方向描述 组件相关语句 ... 其大致能分成: 方向描述 组件 线条 子图 方向描述 方向描述是用来规定流程图的方向的,具体语法如下 选项 说明 TB 方向从上至下 BT 方向从下至上 LR 方向从左至右 RL 方向从右至左 组件 组件是用来表示相关过程的,由id和括号组成,id是用来标识组件的的,具体语法如下 text是自定义文本 id可以用别的英文名替换 选项 说明 id(text) 圆角矩形 id[text] 矩形 id{text} 菱形 id&gt;text] 旗帜形 id((text)) 圆形 线条 线条是流程图各个组件之间的联系 text是自定义文本 选项 说明 --- 简单线条,无箭头 --&gt; 有箭头的简单线条 --text--- 无箭头简单线条附带文字 --text--&gt; 有箭头简单线条附带文字 === 无箭头粗线条 ==&gt; 有箭头粗线条 ==text=== 带文字无箭头粗线条 ==text==&gt; 带文字有箭头粗线条 -.-- 无箭头虚线 -.-&gt; 有箭头虚线 -.text.-- 带文字无箭头虚线 -.text.-&gt; 带文字有箭头虚线 由此,一个流程图所需的语法已经介绍完毕,子图我现在运用过少先不介绍了,接下来是一份基本例子 graph TB start(开始)--&gt;opt1[事件1] opt1--&gt;if1{判断1} if1--Y--&gt;opt2[事件2] opt2-.如果累了.-&gt;opt4((休息一下)) if1--N--&gt;opt3[事件3] opt2--&gt;endd(结束) opt3--&gt;endd graph TB start(开始)--&gt;opt1[事件1] opt1--&gt;if1{判断1} if1--Y--&gt;opt2[事件2] opt2-.如果累了.-&gt;opt4((休息一下)) if1--N--&gt;opt3[事件3] opt2--&gt;endd(结束) opt3--&gt;endd 类图 类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。它既用于应用程序的系统分类的一般概念建模，也用于详细建模，将模型转换成编程代码。类图也可用于数据建模。-百度百科&quot;类图&quot; 类图的创建语法基本如下 classDiagram 类图的语句 ... 其内容大致能分为 类定义 注释 关系 类定义 类图最主要的元素就是类了，定义一个类的方法有多种多样，建议使用比较像编程语言的语法创建类 class NAME{ 成员变量相关 成员函数相关 } 通过上述语法可以在类图中创建一个类，下面讲讲成员变量和成员函数的相关语法 可见性 类的成员有着可见性这一特征，在类图中一般是可见性 类成员直接连着写的，可见性分类如下 符号 说明 + 公有的 public - 私有的 private # 保护的 protected ~ 包内的 package 成员变量和成员函数 mermaid通过()来判定成员变量和成员函数，带有()的就是成员函数,否则为成员变量 加上可见性组合成员变量和成员函数就可以建立一个简单的类了 classDiagram class Student{ -String name; -int age; +Student(String name,int age); } classDiagram class Student{ -String name; -int age; +Student(String name,int age); +getAge() int; } 注意1:mermaid中想使用List&lt;int&gt;这样的通用参数或者返回值的话是不能直接使用&lt;&gt;符号的,需要使用~~来代替,也就是List~int~这样的形式。 注意2:mermaid函数返回值需要写在函数声明后,记住有空格,不能写在可见性后 注释 注释分为类的注释和类图中的注释 classDiagram class Animal{ +String gender +isMammal() +mate() } Animal : +int age class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } Animal &lt;|-- Duck Animal &lt;|-- Fish Animal &lt;|-- Zebra 时序图 时序图（Sequence Diagram），又名序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。它可以表示用例的行为顺序，当执行一个用例行为时，其中的每条消息对应一个类操作或状态机中引起转换的触发事件。-百度百科&quot;时序图&quot; 时序图的创建语法基本如下 sequenceDiagram 时序图语句 ... 其内容大致能分为: 参与者 消息线 标注 循环 判断 参与者 参与者是参消息的实体,其创建语法如下: participant name1 participant name2 as 名字2 第1行是创建一个参与者,名字为name1,第2行是创建一个参与者名字叫做name2,但是它有一个别名叫名字2 消息线 消息线是时序图里面各个实体之间相互通信的联系,其说明如下 语法 说明 -&gt; 无箭头的实线 --&gt; 无箭头的虚线 -&gt;&gt; 有箭头的实线 --&gt;&gt; 有箭头的虚线 -x 末端为叉的实线 --x 末端为叉的虚线 注意:由此参与者+消息线就会合并就会发生信息,一般语法是: 参与者 消息线 另一参与者: 信息 #例子 name1-&gt;&gt;name2:msg 标注 标注能够在时序图的某个时间点为实体标注一些信息,一般由Note 位置 实体：文字描述来组成，其位置说明如下 选项 说明 Note left of 标注在实体的左侧 Note right of 标注在实体的右侧 Note over 标注在实体上 循环 循环是在一个时间段内符合某种条件时重复做一件事情,其基本语法如下: loop 循环的条件 循环体描述语句 end 判断 遇到一些需要根据不同情况进行分支选择的时候就需要用到判断语句了,其语法大致有两种,一种是有多分支的,一种是只有一条分支的 多分支: alt 分支条件1 分支语句1 ... else 分支条件2 分支语句2 ... else 分支条件3 ... ... end 单分支,即只有一个条件操作: opt 条件 执行语句 ... end 基本上时序图就是以上的常用语法了,下面给出一个实例: sequenceDiagram title: 实例 participant teacher as 老师 participant stu as 学生 opt 起床了 Note right of stu:上学 Note left of teacher:上课 end stu-&gt;&gt;teacher:老师好 teacher-&gt;&gt;stu:同学们好,请坐 opt 老师应答完毕 Note over stu:坐下 end loop 授课时间 Note right of teacher:老师上课 alt 同学提问 stu-&gt;&gt;teacher:问题 teacher-&gt;&gt;stu:答案 else 老师提问 teacher-&gt;&gt;stu:问题 stu-&gt;&gt;teacher:回答 else 下课时间到了 Note right of teacher:下课 end end opt 下课 teacher-&gt;&gt;stu:同学们再见 stu-&gt;&gt;teacher:老师再见 end Note over teacher,stu:继续日常至放学时间 opt 放学了 Note left of teacher:回家 Note right of stu:回家 end 甘特图 以下节选自百度百科&quot;甘特图&quot;的信息: 甘特图（Gantt chart）又称为横道图、条状图(Bar chart)。其通过条状图来显示项目，进度，和其他时间相关的系统进展的内在关系随着时间进展的情况。以提出者亨利·劳伦斯·甘特（Henry Laurence Gantt）先生的名字命名。 ","link":"https://impressionyang.vercel.app/post/markdown-note-mermaid/"},{"title":"记录一次Hexo的崩溃修复","content":"问题复现 这次崩溃的原因是安装主题的时候手贱终止了一次然后就出了问题，导致hexo的各种命令如clean、generate、server等一直报警告并且导致网页资源的渲染出问题从而使得网站运行异常 而这次发帖是为了记录本次的修复过程以提供后用 修复的原理 我们都知道hexo的目录下面有一个node_modules文件架夹和一个package.json文件（安装插件后会自动生成），文件夹是保存了各个插件的文件依赖，json文件是保存了hexo的各个依赖组件，使用npm install可以根据此文件进行批量安装。 更新/安装中断或者操作插件的时候导致的异常一般是因为node_modules文件夹里面的文件出问题或者丢失 所以我们遇到什么困难也不要怕，微笑着干掉它，没错，直接把node_modules文件夹整个删掉、删掉、删掉。 然后就没有问题了，因为整个问题的根源已经没有了233，开玩笑的，基本上只要把插件重新一个个安装完基本上就没事了，当然，如果你在折腾主题的话还需要先把主题会复制折腾之前哦。 恢复 既然知道了原因，那么就直接使用命令修复它吧 删除node_modules rm -rf node_modules 恢复主题至折腾之前，然后重新安装插件 cnpm install --save 重新生成网页测试 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 如果没出问题的话基本上博客网页又能恢复正常咯 impressionyang ","link":"https://impressionyang.vercel.app/post/hexo-broken-fix-note01/"},{"title":"记一次Fcitx5的安装","content":"先导 maybe a new fcitx. Next generation of fcitx. Fcitx 5 is a generic input method framework released under LGPL-2.1+. 以上是github上记录的fcitx5的仅有的寥寥几笔，想看到更多的内容请查看老K的文章 这篇帖子是记录我安装Fcitx5的经历，反正是折腾了很久才配置成功的，也看了很多其他人的配置，记录成功安装方法以留作以后参考 安装 由于fcitx5的相关组件已经全部被Arch收录至community源中了，所以这也是我想要安装它的一个原因。 需要安装fcitx5 fcitx5-chinese-addons fcitx5-gtk fcitx5-qt kcm-fcitx5 fcitx5-rime sudo pacman -S fcitx5 fcitx5-chinese-addons fcitx5-gtk fcitx5-qt kcm-fcitx5 fcitx5-rime 其中，fcitx5是核心组件，fcitx5-chinese-addons是一个中文插件，包含了Fcitx的IME组件，fcitx5-gtk fcitx5-qt是Fcitx5的gtk模块和qt模块，kcm-fcitx5是Fcitx5的KDE设置模块，fcitx5-rime是Fcitx5的中州韵输入法 配置 我就是在配置Fcitx5的时候吃了大亏，所以要仔细看清楚配置步骤，首先需要确定你的图形管理是X11的还是Wayland的，确定的方法可以在控制台输入 loginctl show-session 2 -p Type 或者 loginctl show-session &quot;$XDG_SESSION_ID&quot; -p Type 如果有输出x11的字样就是X11的，否则为Wayland的。 由此，会有两种配置方法，两者由自己的情况自己选择其中的一种 X11 X11需要配置的文件有~/.xprofile和~/.xinitrc 在~/.xprofile中添加 export GTK_IM_MODULE=fcitx5 export XMODIFIERS=@im=fcitx5 export QT_IM_MODULE=fcitx5 fcitx5 &amp; 注意：添加fcitx5 &amp;是为了能让Fcitx5登陆时启动 在~/.xinitrc中则添加 export GTK_IM_MODULE=fcitx5 export XMODIFIERS=@im=fcitx5 export QT_IM_MODULE=fcitx5 注意：上述内容需要添加在exec $(get_session)之前 Wayland Wayland则需要编辑的文件是~/.pam_environment 在~/.pam_environment中添加 GTK_IM_MODULE DEFAULT=fcitx5 QT_IM_MODULE DEFAULT=fcitx5 XMODIFIERS DEFAULT=@im=fcitx5 配置总结 以上就是Fcitx5的常规配置过程了，需要注意的有几点： 添加fcitx5 &amp;是为了能让Fcitx5登陆时启动 Xprofile添加的内容需要添加在exec $(get_session)之前 若是在Wayland下配置开机不能启动Fcitx5（少数异常情况）请自行添加Fcitx5的开机启动 一些问题的解决 设置输入法 上面其实已经安装了Fcitx5的图形设置界面了，其位置在系统设置-&gt;区域设置-&gt;输入法里面，可以对Fcitx5进行自定义的一些配置。 主题不好看 如果觉得下载的主题配置不好看，KDE下可以直接在某个面板中添加小部件输入法面板即可自动使用当前的KDE主题风格，而且可以覆盖设置字体大小和候选字显示方向，很舒服 具体可以看我的效果哈哈哈。 wine或者deepin-wine的一些配置 原因：locale设置或者启动环境的问题 解决方法： 通过脚本设置locale和环境启动软件 其中，deepin-wine的配置最容易，因为deepin-wine的软件本身都是由脚本启动的，只需要添加以下内容 env locale=zh_CN export XIM=&quot;fcitx5&quot; export GTK_IM_MODULE=&quot;fcitx5&quot; export XMODIFIERS=&quot;@im=fcitx5&quot; export QT_IM_MODULE=&quot;fcitx5&quot; 至/opt/deepinwine/apps/对应软件/run.sh内的运行语句之前即可，怕出问题可直接添加至文件首。 而wine的话需要自己在写一个run.sh，在其中添加上述环境设置后写一个运行语句即可，例子如下： #!/bin/sh env locale=zh_CN export XIM=&quot;fcitx5&quot; export XMODIFIERS=&quot;@im=fcitx5&quot; export GTK_IM_MODULE=&quot;fcitx5&quot; export QT_IM_MODULE=&quot;fcitx5&quot; wine ~/.wine/drive_c/Program\\ Files\\/QQ/Bin/QQ.exe 使用nohup sh ru.sh &amp;&gt;/dev/null &amp;即可后台运行该脚本 待解决 wps office的中文输入，编辑/usr/bin/wps添加环境设置也无效 难搞，但是Fcitx5是真的香(๑˃̵ᴗ˂̵)و，内存占用也很舒服 impressionyang ","link":"https://impressionyang.vercel.app/post/fcitx5-install-note/"},{"title":"C++和Java的变量对比","content":"C++和Java的变量对比 本贴创建的原因是本人需要做一个C++和Java之间进行socket通信的时候想要确定一下两者之间变量的内存占用情况，经过验证测试得出的结果用于以后用来进行验证 本次的结果均是在32位系统中得到的，64位的操作系统的内存占用情况可能有所不同！ 对比的表格如下: C++ usage Java usage short 2 bytes short 2 bytes int 4 bytes int 4 bytes long 4 bytes long 8 bytes long long 8 bytes float 4 bytes float 4 bytes double 8 bytes double 8 bytes long double 12 bytes bool 1 byte boolean 1 byte char 1 byte char 2 bytes unsigned char 1 byte byte 1 bytes 后记 在进行跨平台的socket套接字连接是需要注意变量内存问题 impressionyang ","link":"https://impressionyang.vercel.app/post/cpp-java-variable-diff/"},{"title":"解决KDE下KDE Wallet重装系统后每次登陆需要输入密码","content":"解决KDE下KDE Wallet重装系统后每次登陆需要输入密码 在每次重装或者配置桌面后kdewallet总是在登陆系统之后提示输入密码，虽然在输入密码后能够继续正常使用，但是每次登陆系统都需要输入一次密码还是很烦人的，所以记录本帖以留作后用 出现的原因 在重新配置桌面或者重装系统之后KDE Wallet所需要的一些必备需要依赖组件未能找到，所以导致不能正确运行KDE Wallet，所以只要安装其所需的组件即可。而其所需的但是未能自动安装的依赖组件正是kwallet-pamExtra 解决方案 安装缺失的组件 sudo pacman -S kwallet-pam 为了保险起见，查看个人目录下是否存在~/.kde4/share/apps/kwallet文件夹，如果存在则将其删除或者重命名以避免出现冲突，并且还需要确定使用的钱包名为kdewallet并且密码为当前用户的密码。 如此便可完全正常使用KDE Wallet 本贴解决方案参考arch wiki的KDE Wallet小节中。 impressionyang ","link":"https://impressionyang.vercel.app/post/kde-wallet-login-config/"},{"title":"Hexo + Git Pages搭建个人博客（一）","content":"Hexo + Git Pages搭建个人博客（一） 期待已久的Hexo部署教程终于来了，本次发帖是在经过较长时间地使用Hexo之后才发出的，一成功就发感觉有点不稳，本贴主要是记录了本博客站的最终搭建方案，会分为几个部分，这次就讲讲怎么把Hexo运行起来的方法。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装和配置Hexo 安装 安装前准备 由于Hexo依赖Node.js，所以必不可少的使用了npm来进行安装插件，所以需要提前安装好Node.js和npm，但是由于npm使用的是境外服务器，所以推荐安装一下淘宝的国内镜像cnpm，还有安装主题文件时可能会使用到git工具，所以也需要安装，具体所有安装如下： 安装Node.js和npm sudo pacman -S nodejs npm 使用npm -v和node -v能看到以下输出即可 安装cnpm npm install cnpm -g --registry=https://registry.npm.taobao.org 安装git sudo pacman -S git 顺利安装完成即可 安装Hexo至本地blog文件夹并配置 安装好环境依赖以后就可以开始着手准备Hexo的安装了，基本上安装除了主题使用git和部署Hexo使用hexo命令外其他都是用cnpm工具，当然，如果你能魔法上网的话用npm也可以 安装Hexo 需要使用超级用户权限才可以安装到全局环境下，这样可以在本地文件系统的任一位置部署Hexo，比较方便 sudo cnpm install -g hexo 顺利安装完成后在控制台终端里面输入hexo -v有如下输出即可 配置 部署Hexo博客根目录 进入到要创建博客的文件目录 以下的YourHexoBlogName都改为你自己需要的文件夹名称 开始部署： hexo init YourHexoBlogName 在经历一段时间的部署后就会在当前目录下多出一个名为YourHexoBlogName的文件夹，里面的目录结构大概如下 . ├── _config.yml #Hexo的配置文件 ├── node_modules #插件及环境目录 ├── package.json #安装的所有包的json归档文件 ├── scaffolds #配置和资源未使用到，不讲 ├── source #存放资源文件夹 ├── themes #存放主题的文件夹 └── yarn.lock #配置未用到，不讲 如果未与上述相符的话要么是本贴太老旧，要么就是你没有安装对咯 安装主题 Hexo官方收录了大量的精美博客主题，只需要前往主题收录地址进行下载，然后解压至theme目录下即可，一般主题都会有一个README文件，里面一般都会讲解说明主题的文件夹名称和主题名称，对好入座后在Hexo的配置文件_config.yml的theme:后面填写对应主题即可。 配置Git Page服务 一般来说一般人是没有个人域名的，更不用说个人服务器了，本贴是基于不需要依托付费的在线方案进行部署Hexo的，所以推荐使用GitHub或者Gitee进行在线部署，这两个在线的托管平台都提供了Git Pages服务，但是这两者之间是有一定差异的，下面讲解： GitHub：提供免费的公开仓库Pages服务，上传自动部署更新，使用似有的仓库进行Pages需要付费；属于境外服务器，国内访问速度不稳定，不推荐使用上传仓库中的图片，建议使用图床。 Gitee：提供免费公共似有仓库的Pages服务，但是上传不能自动部署更新，需要手动更新 ，自动更新需要付费；属于国内服务器，国内访问速度很快，可以使用上传仓库中图片。 根据上述优缺点可以自行进行选择Pages服务的提供商，我个人是使用gitee搭建图床+github搭建博客网站的方法，gitee由于在国内访问图片较快，可以搭建私有仓库并开启Pages服务，每次添加图片可以去更新一下，github可以自动部署更新，无脑上传很方便，外国友人也可访问，大厂风范，使用舒服。 本贴只介绍gitee作为博客网站托管平台 创建仓库 这里需要提前注册gitee帐号，并且实名，不然不能使用Git Pages服务，点击此处前往注册。 创建仓库时建议创建与自己帐号名一致的仓库名，这样在gitee可以获取到一个专有二级域名的网址，如我的用户名impressionyang创建一个同名的仓库之后开启Pages服务得到了一个https://impressionyang.gitee.io的二级域名，而不用使用子文件夹，比较好看。 点击右上角的+号内的创建仓库进行创建仓库 进行信息填写之后按照自己的想法选择私有或者公开之后创建仓库，不要自行添加任何文件哦，比如README什么的。 仓库创建完成后点击仓库资源右边的克隆/下载里面的复制按钮复制仓库地址，留作后用 配置Hexo的deploy配置 如果需要配置Git Pages的话需要配置一下Hexo的_config.yml里面的deploy项，但在此之前，必须要先安装deploy插件，插件安装命令如下： cnpm install hexo-deployer-git --save 接着进行配置，大概配置如下 deploy: type: git repo: 你的仓库地址 branch: master 注意：冒号后面一定要有空格 配置好之后就可以进行上传部署了，在Hexo博客根目录下面运行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 然后hexo就会进行资源文件的清理、生成、部署到git上，部署时根据你的git的验证方式进行即可 impressionyang ","link":"https://impressionyang.vercel.app/post/hexo-init-config-1/"},{"title":"KDE下完美的Unity桌面体验，扔掉active window control","content":"psifidotos 的 applet-window 系列完全实现unity当年风采 熟悉我对Linux桌面态度的人都知道我个人是很推崇当年Ubuntu的Unity桌面的全局菜单的整合功能的，其有着能把窗口标题栏以及窗口按钮和全局菜单整合为一体的功能，能够大大节省屏幕的纵向空间而不影响使用菜单以及查看窗口标题和使用窗口按钮。在我个人看来，Ubuntu的Unity桌面简直就是Linux桌面环境的最强代表，直到它退出历史舞台。 至今我仍然向往那种能够有效率节省屏幕空间的功能却苦于没有什么桌面能够原生支持，但是，在我转向了archlinux+KDE之后便发现了此事有所转机。 一开始我是使用KDE的一个名为active window control的插件进行使用，它能够将窗口标题栏和顶栏进行结合，但是全局菜单需要使用KDE的原生全局菜单插件，并且其使用起来并不是很友好，不过它也能够在一定程度上节省了屏幕的纵向空间，所以也能够勉强够用，但是使用起来并不是很开心。 但是在KDE桌面的强大的可定制化插件的支持下，由psifidotos所编写的applet-window系列插件能够配合Plasma KDE桌面来完美来达成‘这一愿想。 要实现Unity桌面的功能需要安装他写的三个插件： applet-window-title applet-window-buttons applet-window-appmenu 说明：archlinux+KDE（原理上来说manjaro+KDE也可以）在安装好桌面后还需要安装cmake和extra-cmake-modules，一般在安装了这两个编译依赖之后如果还是编译不成功请在评论区说明清楚哦。 安装并配置三个插件 applet-window-title github地址点击此处 克隆仓库 git clone https://github.com/psifidotos/applet-window-title.git 由于此插件使用QML编写，所以可以直接使用命令装入插件 cd applet-window-title plasmapkg2 -i . 图示 至此applet-window-title安装完毕 applet-window-buttons github地址点击此处 克隆仓库 git clone https://github.com/psifidotos/applet-window-buttons.git 因为该插件使用C++进行编写，所以需要进行编译安装 cd applet-window-buttons sh install.sh 图示 基本上如果没有编译依赖缺失的话可以一路编译下去然后自动安装 至此applet-window-buttons安装完毕 applet-window-appmenu github地址点击此处 克隆仓库 git clone https://github.com/psifidotos/applet-window-appmenu.git 同样因为该插件使用C++进行编写，所以需要进行编译安装 cd applet-window-appmenu sh install.sh 图示 基本上如果没有编译依赖缺失的话也是可以一路编译下去然后自动安装 至此applet-window-appmenu安装完毕 配置 applet-window-title applet-window-buttons applet-window-appmenu 后记 现在基本上已经能够得到和Unity桌面那样的机制体验了，舒服。 impressionyang ","link":"https://impressionyang.vercel.app/post/unity-style-applet/"},{"title":"Qt CMake GUI项目生成脚本","content":"自动初始化Linux下Qt通用开发的CMake GUI工程的脚本 这个脚本的来由是在我使用了CMake作为Qt工程的编译工具之后，为了使得即使在没有qtcreator的情况下也能快速地建立CMake Qt GUI工程从而使用其他的文本编辑器如VSCode或者Atom进行开发，而开发的工程建立脚本。 本项目已经发布至我的github 完成的功能 自动构建一个标准的CMake Qt GUI工程 使用了以前的通用懒人CMake模板文件 可以自定义工程名称 从github克隆至本地即可重复使用 脚本 脚本构建的标准项目目录 ProjectName #项目目录 ├── CMakeLists.txt #项目根目录CMakeLists.txt配置文件 └── src #源码目录 ├──utilities #次级原码目录 | ├── CMakeLists.txt #次级源码目录CMakeLists.txt配置文件 | ├── util.h #其他次级源码 | └── util.cpp #其他次级源码 ├── CMakeLists.txt #源码目录CMakeLists.txt配置文件 ├── main.cpp #程序入口 ├── ... #其他项目文件 └── test.cpp #其他项目文件 脚本内容 #! /bin/bash #create by impressionyang on 2020/01/05 echo &quot;start setting up your own project&quot; read -p &quot;please input your project name:&quot; project_name read -p &quot;please input your runable file's name:&quot; file_name cp -r cmaketest $project_name sed -i &quot;s/cmaketest/$project_name/g&quot; $project_name/CMakeLists.txt sed -i &quot;s/cmaketest/$file_name/g&quot; $project_name/src/CMakeLists.txt echo &quot;project setup finish, please copy your project to your workspace and enjoy your development!&quot; 脚本原理 脚本同级目录下有一个标准的项目工作目录，此目录是为了提供一个标准的工程项目模板而存在的，结构如上述脚本构建的标准项目目录。而脚本的工作原理就是通过读入你设置的工程名和可执行文件名之后复制一份标准工程目录然后通过字符串定位修改相应值从而产生一个新的通用编辑器的工程了。 使用 克隆项目至本地 git clone https://github.com/impressionyang/qt_cmanke_project_initialize.git 运行setup.sh文件并设置项目名和可执行文件名（使用英文！！！） sudo chmod +x setup.sh ./setup 将当前新生成的项目目录拷贝至你的工作目录下进行编程即可 impressionyang ","link":"https://impressionyang.vercel.app/post/auto-init-cmake-qt-project/"},{"title":"终端shell美化","content":"终端美化 终端是Linux用户的一大特色，对于经常使用终端的我来说，单调的配色和命令行已经使我有点审美疲劳了，配色可以使用首选项配置，但是命令行的模式我是有点犯尴尬症，所以重新配置了下终端并写了这篇帖子 bash和powerlinepowerline 配置 bash相信是很多接触Linux系统的人使用的最频繁的shell了，作为普遍使用的终端shell，bash也是可以进行美化的，美化方案就是powerline 安装 安装 powerline及字体 sudo pacman -S powerline sudo pacman -S powerline-fonts sudo pacman -S powerline-vim 配置 bashrc 配置（注意python版本），使用命令vim ~/.bashrc，并将以下内容加入文件中 # powerline powerline-daemon -q POWERLINE_BASH_CONTINUATION=1 POWERLINE_BASH_SELECT=1 . /usr/lib/python3.7/site-packages/powerline/bindings/bash/powerline.sh 应用: source ~/.bashrc 效果 zsh和oh-my-zsh 虽然在bash下有了powerline这一主题，但是经过了解还有一个zsh支持更多的美化主题，特别是使用了oh-my-zsh插件后还有更多的功能，以下是安装及配置方法 安装 安装 zsh sudo pacman -S zsh 安装 oh-my-zsh 三个选一个 sh -c &quot;$wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)” 或 wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh sh install.sh 或 https://github.com/robbyrussell/oh-my-zsh/archive/master.zip 查看相关命令 查看已有的shell cat /etc/shells 查看当前shell echo $SHELL 替换shell 使用zsh替换bash（重新打开终端生效） chsh -s /bin/zsh 还原bash（需要重启） chsh -s /bin/bash 查看zsh版本 zsh --version 语法高亮 https://github.com/zsh-users/zsh-syntax-highlighting 因为使用了 oh-my-zsh 故安装简单很多直接 $ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 然后在 ~/.zshrc 中加入插件 plugins=( zsh-syntax-highlighting ) 效果 impressionyang ","link":"https://impressionyang.vercel.app/post/console-beautify-config/"},{"title":"GoldenDict个人配置","content":"GoldenDict个人配置 --一款支持Linux的强大单词翻译软件 以下来自百度百科 GoldenDict 是一款不错的、与StarDict（星际译王）类似的词典软件。它使用 WebKit作为渲染核心，格式化、颜色、图像、链接等支持一应俱全；支持多种词典文件格式，包括Babylon的 .BGL 文件、StarDict 的 .ifo/.dict/.idx/.syn 文件、Dictd的·index/.dict(.dz) 文件、ABBYY Lingvo 的 .dsl/.lsa/.dat 文件。 安装 sudo pacman -S goldendict 配置 安装之后会发现基本上GoldenDict是基本上用不了的，因为词典匮乏，基本上差不了太多的单词，这是就需要进行相关的词典配置了； GoldenDict支持本地离线词典和在线词典两种查询方式 离线词典 不知道去哪里下载离线词典的可以点击此处去本人找到的这一个网站去下载，这其实是星际译王的词库网站，恰好GoldenDict支持这一种词典格式。 下载相应词典之后将文件解压至某一个合适的文件夹并且记住文件夹的路径。 然后在编辑-&gt;词典-&gt;词典来源-&gt;文件中添加一个文件路径，就填写刚才解压到的文件夹的目录，然后勾选递归搜索，以便以后加入新词典的时候能查找到，新加入词典后点击右下角的重新扫描即可。 在线翻译源 在线翻译的话推荐使用 有道和 必应，其翻译使用地址如下 有道： http://dict.youdao.com/search?q=%GDWORD%&amp;ue=utf8 必应： https://cn.bing.com/dict/search?q=%GDWORD% 同样的，在编辑-&gt;词典-&gt;词典来源-&gt;网站中，添加一个一个网址，将上述信息填入，并且将其他用不了的地址的启用取消。 后记 好了，现在已经是安装并且配置好了，在使用的时候自己在首选项配置好之后就可以使用主界面或者划词器进行翻译单词了。 impressionyang ","link":"https://impressionyang.vercel.app/post/goldendict-personal-config/"},{"title":"markdown数学公式","content":"markdown数学公式 此贴用来记录日常使用的markdown数学公式以供参考 不定时更新 本文所用的公式渲染器是KaTeX，相关语法支持请点击此处查看 行内或独立公式语法 行内公式 将公式插入到文本内 符号: $公式内容$ 例子: (要表示)公式x+y表示 -&gt; (形式)公式$x+y$ -&gt; (结果)公式x+yx+yx+y 独立公式 数学公式独占一行且居中 符号: $$公式内容$$ 例子: (要表示)x+y -&gt;(形式)$$x+y$$ -&gt; (结果): x+yx+y x+y 运算法则一般公式举例 四则运算 加法，符号：+，表示：$x+y=z$，结果：x+y=zx+y=zx+y=z 减法，符号：-，表示：$x+y=z$，结果：x−y=zx-y=zx−y=z 乘法，符号：\\times，表示：$x \\times y=z$，结果：x×y=zx \\times y=zx×y=z 除法，符号：\\div，表示：$x \\div y=z$，结果：x÷y=zx \\div y=zx÷y=z 四则运算扩展 加减法，符号：\\pm，表示：$x \\pm y=z$，结果：x±y=zx \\pm y=zx±y=z 减加法，符号：\\mp，表示：$x \\mp y=z$，结果：x∓y=zx \\mp y=zx∓y=z 点乘法，符号：\\cdot，表示：$x \\cdot y=z$，结果：x⋅y=zx \\cdot y=zx⋅y=z 星乘法，符号：\\ast，表示：$x \\ast y=z$，结果：x∗y=zx \\ast y=zx∗y=z 斜除法，符号：/，表示：$x/y=z$，结果：x/y=zx/y=zx/y=z 绝对值，符号：||，表示：$|a+b|$，结果：∣a+b∣|a+b|∣a+b∣ 分式，符号：\\frac{分子}{分母}，表示：$\\frac{x+y}{y+z}$，结果：x+yy+z\\frac{x+y}{y+z}y+zx+y​ impressionyang ","link":"https://impressionyang.vercel.app/post/markdown-math-support/"},{"title":"Makfile文件的编写","content":"Makfile文件的编写 不定期更新 make和Makefile 以下来自百度百科 make: make是一条计算机指令，是在安装有GNU Make的计算机上的可执行指令。该指令是读入一个名为makefile 的文件，然后执行这个文件中指定的指令。有时make又指GNU Make，GNU Make 是一个用来控制可执行文件和其他一些从源文件来的非源代码文件版本的软件。 Makefile: 一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，也可以执行操作系统的命令。 Makefile编写 以下是本人自己比较喜欢用的Makefile的使用方式的总结，一般为单个项目产生单个可执行文件，一般是控制台程序或者opencv相关 简单的多文件的C/C++控制台程序 文件目录是： ProjectName #项目目录 ├── Makefile #项目根目录Makefile配置文件 ├── main.c #mian方法，include了stack.h ├── stack.h #站结构定义 └── stack.c #栈方法实现 Makefile文件内容总览 object = main.o stack.o main : $(object) gcc -o main $(object) main.o : main.c stack.o : stack.h stack.c .PHONY : clean clean: rm $(object) 注意: 如果是编译C++的项目就需要在main生成的命令里面把gcc编译程序换成g++ 解释 上述是我的C/C++多文件编译一般使用的Makefile编写风格，因为没有特殊的中间文件操作，所以都是用的make的自动规则，下面解释上面Makefile内容，基本上可以分成4部分： 在此之前，先说明一下Makefile基本规则： 基本上按照以下模板： target ... : dependes ... command ... 目标(target)：目标顶格写，后面是冒号（冒号后面是依赖）。目标文件, 可以是 Object File, 也可以是可执行文件。 依赖（dependes）： 依赖是用来产生目标（target）的目标文件。 命令（command）：命令前面一定是Tab，不能是定格，也不能说多个空格。命令就是要生成那个目标需要做的动作（任意的shell命令）。 接下来继续讲解 一、目标及所有依赖定义 这部分是为了定义包含的链接目标文件 这部分对应的内容是 object = main.o stack.o 此处使用目标名object包含了main.o和stack.o中间文件，这两个文件需要在下一部分中声明其生成方式。 二、声明目目标执行文件的生成方式 这部分是为了生成最终的可执行文件 这部分对应的内容是 main : $(object) gcc -o main $(object) 此部分规定了最终的目标文件的生成规则 三、声明依赖的目标文件生成 这部分是声明所有依赖的文件的生成方式，使用了make的默认生成规则,语法是 目标文件: 依赖的头文件和源文件 这部分对应的内容是 main.o : main.c stack.o : stack.h stack.c 对应生成的是object的所有依赖文件 四、指定clean规则 这一步其实可以省略，主要目的是制定一个清理生成的中间文件的选项 这部分对应的内容是 .PHONY : clean clean: rm $(object) .PHONY : clean是说明clean是一个伪目标文件，从而不会对clean使用目标文件的生成。 该部分的主要内容就是rm $(object)这条命令，它会删除object的所有依赖的目标文件，如果存在的话。 使用 生成可执行文件 make 清除中间文件 make clean impressionyang ","link":"https://impressionyang.vercel.app/post/Makefile_personal_config/"},{"title":"CMake编写总结","content":"CMake编写总结 不定期更新 CMake介绍 以下来自百度百科 CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。只是 CMake 的组态档取名为 CMakeLists.txt。CMake 并不直接建构出最终的软件，而是产生标准的建构档（如 Unix 的 Makefile 或 Windows Visual C++ 的 projects/workspaces），然后再依一般的建构方式使用。这使得熟悉某个集成开发环境（IDE）的开发者可以用标准的方式建构他的软件，这种可以使用各平台的原生建构系统的能力是 CMake 和 SCons 等其他类似系统的区别之处。 CMake和make 以下来自百度百科 “CMake”这个名字是“cross platform make”的缩写。虽然名字中含有“make”，但是CMake和Unix上常见的“make”系统是分开的，而且更为高阶。 make和CMake之间的关系是CMake 通过命令可以生成make执行的Makefile文件，所以说CMake 是make 的升级版的生成工具 CMake文档 点击此处到达CMake的在线文档页面。 各种CMake编写 以下收录的是本人自己的各种项目的CMakeLists.txt文件，以做参考 CMakeLists.txt一般使用格式 #set minimum compile version CMake_minimum_required(VERSION 3.14) #set project name project(CMaketest) #set target app name set(TARGET_NAME test) ... #genarate a app add_executable(${TARGET_NAME} 源文件 头文件) 简单C++项目编写CMakeLists.txt 简单项目是指只有一个文件夹，并且所有项目文件都放在其中的项目，由于文件结构简单，直接使用一下内容即可将项目进行编译。 ProjectName #项目目录 ├── CMakeLists.txt #项目根目录CMakeLists.txt配置文件 ├── main.cpp #程序入口 ├── ... #其他项目文件 └── test.cpp #其他项目文件 在当前项目文件夹新建CMakeLists.txt文件，并输入以下内容 #set minimum compile version CMake_minimum_required(VERSION 3.14) #set project name project(CMaketest) #set target app name set(TARGET_NAME test) #use c++ 17 stander set(CMake_CXX_STANDERD 17) #set all resources files file(GLOB SOURCES &quot;*.cpp&quot;) file(GLOB HEADERS &quot;*.h&quot;) #genarate a app add_executable(${TARGET_NAME} ${SOURCES} ${HEADERS}) **注意：**简单项目不推荐使用GLOB_RECURSE，因为他会遍历所有找到的文件夹以及他的子文件夹，容易造成把build目录扫描导致main函数重复定义的情况 完成后用CMake编译生成makefile，即可使用make命令进行项目的编译了 复杂（多文件夹）C++项目写CMakeLists.txt 复杂项目示例 一般有较多文件的项目都是使用多文件夹进行管理项目源文件的，使用多个不同级目录下保存源文件的管理方式使用CMake生成makefile可以使用以下管理方式 ProjectName #项目目录 ├── CMakeLists.txt #项目根目录CMakeLists.txt配置文件 └── src #源码目录 ├──utilities #次级原码目录 | ├── CMakeLists.txt #次级源码目录CMakeLists.txt配置文件 | ├── util.h #其他次级源码 | ├── util.cpp #其他次级源码 | ├── ... #其他次级源码 | └── log.cpp #其他次级源码 | ... #其他次级原码目录 ├── CMakeLists.txt #源码目录CMakeLists.txt配置文件 ├── main.cpp #程序入口 ├── ... #其他项目文件 └── test.cpp #其他项目文件 复杂项目的CMakeLists.txt CMakeLists.txt #项目根目录CMakeLists.txt配置文件 #set minimum compile version CMake_minimum_required(VERSION 3.14) #set project name project(CMaketest) #add the src subdirectory add_subdirectory(src) CMakeLists.txt #源码目录CMakeLists.txt配置文件 #set minimum CMake compile version CMake_minimum_required(VERSION 3.14) #set target app name set(TARGET_NAME testCMake) #use c++ 17 stander set(CMake_CXX_STANDERD 17) # add a source file subdirectory add_subdirectory(utilities) #set all resources files file(GLOB_RECURSE SOURCES &quot;*.cpp&quot;) file(GLOB_RECURSE HEADERS &quot;*.h&quot;) #genarate a app add_executable(${TARGET_NAME} ${SOURCES} ${HEADERS}) CMakeLists.txt #次级源码目录CMakeLists.txt配置文件 其他次级原码目录CMakeLists.txt配置文件一样 可以不配置，因为使用了源码目录的CMakeLists.txt使用了GLOB_RECURSE，正常情况会自动遍历到此文件夹下 #set minimum compile version CMake_minimum_required(VERSION 3.14) #set all resources files file(GLOB_RECURSE SOURCES &quot;*.cpp&quot;) file(GLOB_RECURSE HEADERS &quot;*.h&quot;) 这样就可以对多个文件夹管理的项目使用CMake生成makefile了 qt项目编写CMake qt项目需要添加相应的库，只需要将一些配置项添加在源码目录CMakeLists.txt配置文件即可 #set minimum CMake compile version CMake_minimum_required(VERSION 3.14) #set target app name set(TARGET_NAME testCMake) #use c++ 17 stander set(CMake_CXX_STANDERD 17) set(CMake_CXX_STANDARD_REQUIRED ON) #include this priject on set(CMake_INCLUDE_CURRENT_DIR ON) #auto genarate ui.h file set(CMake_AUTOUIC ON) #auto genarete moc file set(CMake_AUTOMOC ON) #auto genarate .qrc file on set(CMake_AUTORCC ON) # set QT type set(QT Core Gui Widgets Network DBus Sql) #add package lib find_package(Qt5 REQUIRED ${QT}) # add a source file subdirectory #add_subdirectory(utilities) #set all resources files file(GLOB_RECURSE SOURCES &quot;*.cpp&quot;) file(GLOB_RECURSE HEADERS &quot;*.h&quot;) file(GLOB_RECURSE FORMS &quot;*.ui&quot;) file(GLOB_RECURSE RESOURCES &quot;*.qrc&quot;) #genarate a app add_executable(${TARGET_NAME} ${SOURCES} ${HEADERS} ${FORMS} ${RESOURCES}) #add QT5 dependes target_link_libraries(${TARGET_NAME} PRIVATE Qt5::Widgets) 使用 在当前文件夹下使用一下命令可以生成Makefile： cmake 但是，如此生成的话会产生很多中间文件，从而导致了当前文件夹的文件过多，再次编辑文件的时候会很难找到确切的文件的状况，这就是污染项目结构 所以，为了不污染项目环境，推荐使用以下命令来生成Makefile mkdir build cd build cmake .. impressionyang ","link":"https://impressionyang.vercel.app/post/cmake-personal-config/"},{"title":"archlinux安装篇（二） KDE桌面环境","content":"archlinux安装篇（二） 接着上一次安装完成了之后应该能启动到archlinux的图形界面了，但是没有图形界面的话作为日常使用的系统还是很勉强的，所以还是很有必要进行接下来的图形操作界面的配置的 接下来就是配置archlinux的图形操作环境了，本文介绍的是Plasma KDE桌面环境 安装 安装核显驱动 以下的amd和intel核显驱动二选一，按照自己的具体情况来确定 #amd sudo pacman -S xf86-video-ati #intel sudo pacman -S xf86-video-intel 安装显示管理器及登陆主题 sudo pacman -S sddm sddm-kcm 安装Plasma桌面和基本软件包加上Xorg sudo pacman -S plasma-desktop xorg-server kdebase 现在基本上是已经安装好了图形界面环境了，可以使用命令startx进行测试 现在还不可以重启，还需要进行下一步的配置 配置 虽然已经安装好了图形桌面环境，但是开机并不会进入到图形登录界面，因为相关的组件并没有启动，需要在安装好组建之后进行配置 配置显示管理器开机自启 sudo systemctl enable sddm 现在已经基本可以通过图形界面的方式登录到桌面环境了，接下来的其他配置就以后再讲 impressionyang ","link":"https://impressionyang.vercel.app/post/archlinux-install_2/"},{"title":"盘点C/C++语言编程+编译工具","content":"盘点C/C++语言编程+编译工具 本帖子盘点了Linux下的各种C/C++的编程+编译工具及IDE（集成开发环境 主要是收集Arch Linux下的 目录 vim+gcc/g++ VSCode Code::Blocks QtCreator Clion Eclipse 各软件配置 注意的一点是C的源文件是.c，C++的源文件是.cpp 本文只介绍了单文件的编译运行，多文件共同编译运行以后再讲 vim+gcc/g++ 安装 sudo pacman -S vim gcc 使用 vim编写程序 使用vim 源文件.c或者vim 源文件.cpp来打开C/C++文件 进入vim后使用i进入插入模式 编程完成后按Esc后进入命令模式后输入:wq进行保存退出 gcc/g++编译程序 C使用命令gcc 源文件名.c -o 源文件名来生成可执行文件，C++使用命令g++ 源文件名.cpp -o 源文件名来生成可执行文件。 编译程序其实也可以用make命令，但是这个设计后面的多文件编译，以后在介绍 运行程序 使用上面gcc或者g++命令生成可执行文件后在当前可执行文件目录下使用./可执行文件名即可运行程序。 VSCode 安装 推荐配置好archlinuxcn源之后安装其visual-studio-code-bin。 sudo pacman -S visual-studio-code-bin 插件配置 推荐安装下列插件 编程及运行 新建文件并命名为.c或者.cpp文件 编程 点击右上角运行图标运行 Code::Blocks 安装 sudo pacman -S qtcreator qt5 sudo pacman -S codeblocks 配置控制台 需要在settings-&gt;enviromment-&gt;Terminal to luanch console program中设置为自己需要使用的终端。 编程运行 打开或者新建一个C/C++的源文件 编程 点击编译运行图标编译运行程序 QtCreator 安装 sudo pacman -S qtcreator qt5 编程运行 新建一个C或者C++工程 编程 点击右下角运行按钮运行程序 可能需要配置的问题：程序没有在终端中运行，而是在qtcreator内，当然，如果你不介意也无需在配置 只需要在项目-&gt;run-&gt;run in terminal勾选即可 Clion 安装 sudo pacman -S clion 编程 新建C或者C++工程 编程 点击run Eclipse 安装 sudo pacman -S eclipse 也可以去官网下载安装可执行二进制软件包，无安装，直接运行 配置插件 需要安装CDT插件以使得Eclipse可以支持C/C++ 编程运行 新建C/C++工程 编程 build 运行 没有运行实例哦，傻眼了吧，这玩意安装是很不方便的，所以我并不推荐，但是eclipse cdt基本上就是按照上述步骤运行的，所以加油。 impressionyang ","link":"https://impressionyang.vercel.app/post/C-CPP-Tools-Collect/"},{"title":"Plasma顶栏和窗口标题整合插件","content":"Plasma顶栏和窗口标题整合插件 Active Window Controle 窗口集成功能 Active Window Controle经过配置可以使得你的Plasma的窗口与顶栏相结合，达到Ubuntu曾经使用的Unity桌面环境那般高效，可以在全屏是节省一条标题栏的高度，毕竟显示器区域真的是寸土寸金的呀。 安装 此插件在archlinuxcn源中有： sudo pacman -S plasma5-applets-active-window-control-git 也可以使用系统自带安装器搜索安装，但是不推荐在KDE Store上下载安装，因为在KDE Store上安装自行编译需要一定的编程功底，而且还容易因为编译依赖及系统环境的因素而无法编译成功。 配置 安装完成后外观和按钮使用如下配置，窗口按钮路径就是个人文件夹下的aurorae下，其他的看个人，就可以达成Unity桌面的效果。 impressionyang ","link":"https://impressionyang.vercel.app/post/active_window_control/"},{"title":"一个命令进行Plasma热重启","content":"一个命令进行Plasma热重启 通过一个命令来重启Plasma桌面来释放系统资源 KDE Plasma桌面环境具有很多炫酷的显示效果，但是经过一天下来长时间使用Plasma桌面而不待机或者睡眠的话，Plasma桌面会占用大量的内存资源，为了解决这个问题，特地写了一个脚本文件来对Plasma桌面进行热重启，从而释放一些资源的占用 思路基本上就是使用Plasma的指令先关闭Plasma桌面再启动它 脚本文件内容 具体内容： #! /bin/bash kquitapp5 plasmashell &amp;&amp; kstart5 plasmashell 命名：restart_kde，注意，没有后缀名 赋权 使用文本工具或者vim进行编写，编写完成后对其进行运行权限的赋权： sudo chmod +x restart_kde 复制至bin文件夹 将脚本文件移至path中指定的系统变量路径，可放至/usr/local/sbin、/usr/local/bin，/usr/bin中。 移动命令： sudo cp restart_kde /usr/bin 使用方法 用KRunner，Alt+Space唤醒，确保KRunner拥有执行命令的功能 输入restart_kde即可 impressionyang ","link":"https://impressionyang.vercel.app/post/restart_kde/"},{"title":"wine和deepinwine的相关配置","content":"wine和deepinwine的相关配置 安装wine sudo pacman -S wine wine-mono wine-gecko 配置 字体 可以通过更改注册表的方式更改wine调用的字体 注册表文件内容：zh.reg 内容大概就是把wine调用的windows自体改成Linux安装好的字体，可以自行修改自己想要的字体文件，我这里是全部替换成文泉驿字体的雅黑字体了 REGEDIT4 [HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink] &quot;Lucida Sans Unicode&quot;=&quot;wqy-microhei.ttc&quot; &quot;Microsoft Sans Serif&quot;=&quot;wqy-microhei.ttc&quot; &quot;Microsoft YaHei&quot;=&quot;wqy-microhei.ttc&quot; &quot;微软雅黑&quot;=&quot;wqy-microhei.ttc&quot; &quot;MS Sans Serif&quot;=&quot;wqy-microhei.ttc&quot; &quot;Tahoma&quot;=&quot;wqy-microhei.ttc&quot; &quot;Tahoma Bold&quot;=&quot;wqy-microhei.ttc&quot; &quot;SimSun&quot;=&quot;wqy-microhei.ttc&quot; &quot;Arial&quot;=&quot;wqy-microhei.ttc&quot; &quot;Arial Black&quot;=&quot;wqy-microhei.ttc&quot; &quot;宋体&quot;=&quot;wqy-microhei.ttc&quot; &quot;新細明體&quot;=&quot;wqy-microhei.ttc&quot; 打开注册表控制面板 wine regedit 然后选择导入注册表文件，选择刚才的zh.reg文件即可 DPI 发现有字体显示过小的问题可以调整wine的DPI设置 打开wine配置面板 WINEARCH=win32 WINEPREFIX=~/.wine winecfg deepin-wine配置面板 TIM env WINEPREFIX=&quot;$HOME/.deepinwine/Deepin-TIM&quot; winecfg deepin-wine无法启动应用 解决方法来自B站up：等我稍后补充昵称 主要思路：可能是deepin-wine在打包时无意间加入了gnome依赖。所以补齐依赖就可以了。 方法很简单，安装gnome-settings-daemon,安装代码：sudo pacman -S gnome-settings-daemon 之后，将/etc/xdg/autostart/org.gnome.SettingsDaemon.XSettings.desktop 复制到 ～/.config/autostart/ 最后，去往设置—开机和关机—自动启动 中，将org.gnome.SettingsDaemon.XSettings.desktop的一项勾选启动即可。 impressionyang ","link":"https://impressionyang.vercel.app/post/wine_deepinwine_config/"},{"title":"archlinux安装与应急使用双用U盘","content":"archlinux安装与应急使用双用U盘 本次方案建议使用16G及以上的U盘进行安装，以保证得到较好的体验 建议使用USB3.0及以上的U盘，当然2.0也没问题，如果不使用图形界面的话 本次是在linux环境下完成的，当然Windows下也可以实现 使用意义 在使用archlinux启动盘之前需要用dd命令将U盘刻为启动盘，这样就导致整个U盘分区被dd修改，最明显的是第一个装有安装环境的分区被分配了一个iso9960标志并且使用cfdisk打开该设备是会有提示使用写命令是会丢失丢失该标志从而导致标签异常使得启动异常，而安装环境仅有600+M，白白浪费了该启动盘的其他空间，因为不可以新建分区。 另一方面，对于某些情况下，例如电脑的系统炸了，但是又要很快地进行某些工作的时候，例如运维、出差是别的电脑是win系统等情况时，需要尽快的使用linux操作系统的时候，如果有一个装在U盘里面的移动的linux操作系统就可以解决燃眉之急了，并且，在日常使用的时候也可以偶尔使用U盘里面的linux系统 一些想体验linux操作系统又怕把自己的电脑搞坏的人也可以使用这一方案进行双系统使用，而不是去使用linux live环境。 所以，在以上的需求之下，这一使用方案就从我的脑子应运而生了。 基本想法 主要实现的基本想法就是通过将刻好的启动盘的内容复制出来后在重新格式化U盘重新分区并尽量将前两个分区模仿原有的启动盘方案，然后剩下的分区在重新利用。 ，使用gparted或者blkid（Windows可以使用分区工具查看）查看U盘经过dd刻录之后的文件系统和标签。 之后使用mount命令将其第一和第二个分区挂载后将其内容复制出来 准备阶段 USB移动U盘或者移动硬盘一个 archlinux安装镜像一个 virtualbox等虚拟机或者是使用实体机一台 开始配置 刻录启动盘 首先下载archlinux的iso镜像，然后使用dd命令刻录一个启动U盘。 archlinux镜像下载地址(清华https) sudo dd if=/path/to/archlinux/iso of=/path/to/your/Udisk /path/to/archlinux/iso是iso镜像路径 /path/to/your/Udisk是要刻录的U盘，注意是整个U盘的设备，不要加上分区号！ bs即block size可以直接用默认的 Windows下 windows系统下可以使用rufus的dd刻录 挂载复制分区内容 本步骤目的是把启动盘安装环境分区内容和EFI分区内容复制出来 复制安装环境分区内容目的是让新分区后U盘重设标签后内容能够保持正确 复制EFI分区内容是因为dd默认刻录的时候分配的EFI太小了，只有64MB，而启动盘原有的启动内容本身就已经占用了45MB了，为了保证能够让新安装的linux共享的EFI分区能够有足够的空间，取药新分出一个500MB的EFI分区。 Windows下如果无法访问的话推荐使用虚拟机直接读取archlinux镜像进入安装环境使用纯命令行进行操作 先复制第一分区（安装环境分区） #sdXY是U盘设备的第一个分区号 sudo mount /dev/sdXY /mnt #下面步骤可以用文件管理器代替 cp -r /mnt path/to/save/files umount -R /mnt 在复制第二分区（EFI分区） #sdXY是U盘设备的第二个分区号 sudo mount /dev/sdXY /mnt #下面步骤可以用文件管理器代替 cp -r /mnt path/to/save/files umount -R /mnt 重新分区U盘 推荐使用形化操作的软件进行，linux下推荐使用gparted,Windows下推荐Disk Ginuns 将分区分为msdos格式，也就是MBR，划分出700M，500M，以及剩下空间的三个分区 将700M的分区格式化为fat32,卷标为ARCH_日期年月(如果是2020年2月的话就是ARCH_202002) 将500M分区格式化为fat32,卷标为ARCHISO_EFI。 剩下的那个分区格式化为ext4,也可以不管，在安装linux系统的时候在用，也可以格式化为其他的分区格式作为他用，但是本文是用来安装linux的。 示例 恢复安装盘的个分区内容 再次使用挂载命令将分区挂载，然后将对应的分区内容回复就行，需要注意的是，安装环境的分区卷标是ARCH_日期年月的，启动分区的卷标是ARCHISO_EFI的，不要恢复错误。 安装archlinux 安装archlinux至新分区中，参考文章archlinux安装篇 新系统最好使用bootctl impressionyang ","link":"https://impressionyang.vercel.app/post/USB_boot_multi_use/"},{"title":"arch系的bumblebee安装","content":"arch系的bumblebee安装 bumblebee有什么用 bumblebee是用来进行双显卡切换的工具，专用于具有NVDIA独立显卡以及CPU核显双显卡方案的笔记本来说可以有效的节约电源 有效地进行双显卡的快速切换使用，默认使用核显以节约电量 安装bumblebee 安装依赖 sudo pacman -S virtualgl lib32-virtualgl lib32-primus primus 安装bumblebee archlinux sudo pacman -S bumblebee mesa lib32-virtualgl lib32-nvidia-utils manjaro 使用自带的硬件管理工具 sudo mhwd -f -i pci video-hybrid-intel-nvidia-bumblebee 允许服务 sudo systemctl enable bumblebeed 添加用户组并重启 将$USER替换为自己的用户名 sudo gpasswd -a $USER bumblebee sudo reboot 测试bumblebee optirun glxgears 通过关闭vblank来解锁刷新率 vblank_mode=0 optirun glxspheres 如果帧数还是有问题就是依赖未满足了 设置NVIDIA optirun -b none nvidia-settings -c :8 wine支持 optirun wine application.exe steam支持 在steam游戏的启动选项中添加如下 primusrun %command% 有时optirun更稳定。 optirun %command% 在某些情况下，这些都不起作用（例如在Team Fortress 2中），所以可以使用： LD_PRELOAD=&quot;libpthread.so.0 libGL.so.1&quot; __GL_THREADED_OPTIMIZATIONS=1 optirun %command% vblank_mode=0 PRIMUS_SYNC=1 primusrun %command% vblank_mode=0 primusrun %command% impressionyang ","link":"https://impressionyang.vercel.app/post/arch_sierial_bumblebee_install/"},{"title":"Linux显示bilibili小电视","content":"Linux控制台显示bilibili小电视 不限制linux系统发行版、不限制shell 显示效果 实现步骤 1 制作bilibili小电视文本 文本如下 // \\\\ // \\\\ // ##DDDDDDDDDDDDDDDDDDDDDD## ## DDDDDDDDDDDDDDDDDDDD ## ________ ___ ___ ___ ________ ___ ___ ___ ## hh hh ## |\\ __ \\ |\\ \\ |\\ \\ |\\ \\ |\\ __ \\ |\\ \\ |\\ \\ |\\ \\ ## hh // \\\\ hh ## \\ \\ \\|\\ /_\\ \\ \\\\ \\ \\ \\ \\ \\\\ \\ \\|\\ /_\\ \\ \\\\ \\ \\ \\ \\ \\ ## hh // \\\\ hh ## \\ \\ __ \\\\ \\ \\\\ \\ \\ \\ \\ \\\\ \\ __ \\\\ \\ \\\\ \\ \\ \\ \\ \\ ## hh hh ## \\ \\ \\|\\ \\\\ \\ \\\\ \\ \\____ \\ \\ \\\\ \\ \\|\\ \\\\ \\ \\\\ \\ \\____ \\ \\ \\ ## hh wwww hh ## \\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\ ## hh hh ## \\|_______| \\|__| \\|_______| \\|__| \\|_______| \\|__| \\|_______| \\|__| ## MMMMMMMMMMMMMMMMMMMM ## ##MMMMMMMMMMMMMMMMMMMMMM## welcome impressionyang \\/ \\/ 文本来源,bilibili官网控制台输出 2 配置显示 以下是使用bash进行配置的，对应的是.bashrc配置文件 如果使用别的shell，配置对应设置文件即可 将bilibili小电视文本文件（最好设为隐藏文件）放到个人目录下，与.bashrc同目录 在.bashrc中配置显示bilibili小电视文本文件即可，文末需添加的指令代码如下 cat ～/.bilibili echo 加echo是为了换行，如果文本中已经换行可能就不用加了 impressionyang ","link":"https://impressionyang.vercel.app/post/Linux_show_bilibili/"},{"title":"archlinux生成字符图片","content":"asciiview ---archlinux生成字符图片的程序 控制台生成ascii字符图片的程序 安装 在arch下需要安装的组件有aview aview是将特定的字符矩阵将图片以字符的形式显示出来的程序 asciiview通过调用特定的外部程序如imagemagick等从图片生成那个特定的矩阵序列，到后使用aview将矩阵通过字符的形式显示出来。 aview是在aur中进行维护的，所以要通过aur下载 yay -S aview imagemagick 使用方法 生成字符图片 支持的图片为一般图片如jpg，png等 一般默认命令 asciiview 图片路径 -driver curses 支持的字体有：vga8 vga9 mda14 vga14 X8x13 X8x16 X8x13bold vgagl8 控制字体 asciiview 图片路径 -driver curses -font vga8 示例 原图 保存字符图片 生成图片之后通过s键可以保存图片字符 按s键开始保存 保存为Text file 输入图片宽度和高度以及保存的文件名 选择字体 配置项选择好后按Leave this menu，提示是否保存文件，输入y 保存完毕，按q退出 显示 impressionyang ","link":"https://impressionyang.vercel.app/post/archlinux_asciiview/"},{"title":"git使用要点","content":" 本帖子是用来记录git的使用操作的，会在使用到新功能的时候进行更新，所以本贴是会进行较为长期的更新的 基本命令 初始化配置（$username、 $useremail替换为自己的） git config --global user.name $username git config --global user.email $useremail 建库 1、（先进入项目文件夹）通过命令 git init 把这个目录变成git可以管理的仓库 git init 2、把文件添加到版本库中 git add -A 3、用命令 git commit告诉Git git commit -m 'first' 4、关联到远程库 git remote add origin 你的远程库地址 git remote add origin 'https://git.oschina.net/s/vue.git' 5、获取远程库与本地同步合并 git pull origin master --allow-unrelated-histories 6、使用 git push命令 git push --set-upstream origin master git push -u origin master //github 使用了此条命令 Git冲突：commit your changes or stash them before you can merge（在合并之前提交或保存更改） 利用stash 数据储存 git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。 git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。 git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。 git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。 提交 1、git add .（后面有一个点，意思是将你本地所有修改了的文件添加到暂存区） 2、git commit -m &quot;&quot;(引号里面是你的介绍，就是你的这次的提交是什么内容，便于你以后查看，这个是将索引的当前内容与描述更改的用户和日志消息一起存储在新的提交中) 3、git pull origin master 这是下拉代码，将远程最新的代码先跟你本地的代码合并一下，如果确定远程没有更新，可以不用这个，最好是每次都执行以下，完成之后打开代码查看有没有冲突，并解决，如果有冲突解决完成以后再次执行1跟2的操作 4、git push origin master 将代码推至远程就可以了 git 同步 本地文件 提交更新 git add . git commit -m '内容' git pull origin master git push origin master 拉取到本地 从零开始，在某空文件夹 git init git remote add origin https://github.com/impressionyang/Markdown-Sync.git git pull origin master --allow-unrelated-histories 拉取更改后的更新 git pull origin master ssh公钥配置 一般来说，正常使用git的开始使用http方式获取的，向服务器提交时也是会用帐号密码的方式进行更新，虽然这样做安全系数会更高些，但是随之而来的会发现频繁更新文件提交时输入密码真的是太难受了，所以就有了这种使用ssh公钥配置的方式进行身份验证，减少了帐号密码输入的环节进行提交 生成密钥 如果进行了相关的ssh配置则能够看到如下显示 如果没有事先配置，需要进行ssh密钥的生成，前提是已经设置好了邮箱和用户，命令如下： ssh-keygen -t rsa 配置过程中直接回车3次，第一次是生成密钥文件名,第二次和第三次则是设置密钥的密码，如果不设置密码就直接回车即可，配置好之后即可看到上面图片红框的内容 配置服务器 以github为例，当你生成好密钥之后，能够看到有一个.pub文件，这个叫做公钥，使用cat ~/.ssh/id_rsa.pub命令来查看公钥的内容，将其配置到你的github中的个人配置里面，使用ssh方式获取仓库即可 点击右上角个人图标后弹出的列表中点击settings 点击左侧列表的SSH and PGP keys 点击右上放绿色的New SSH key,输入生成的SSH公钥 fen zhi wait for edit impressionyang ","link":"https://impressionyang.vercel.app/post/git_use_guid/"},{"title":"archlinux安装篇（一） 基本系统","content":"先导 安装ArchLinux 分区并挂载 分区： fdisk -l 查看要安装硬盘符/dev/sdX X代表的是第几个硬盘 cfdisk /dev/sdX 分区工具分区 分区规范uefi 必须要有esp（efi）分区，即 EFI system 必须要有根分区/ 可选： swap分区（内存小需要，RAM&gt;8G就不用了） /home分区（个人文件夹，单独分区以便系统炸了不影响个人数据） 挂载： 1.必须 #此/dev/sdXY为根分区 mount /dev/sdXY /mnt mkdir /mnt/boot #此/dev/sdXY为EFI分区 mount /dev/sdXY /mnt/boot sdXY的X和Y是指存储设备的驱动号，有一些nvme硬盘是显示nvmeXnYpZ,X、Y、Z也是指nvme硬盘驱动号，请使用fdisk -l来查看 2.应用了可选分区的 mkdir /mnt/home #此/dev/sdXY为/home分区 mount /dev/sdXY /mnt/home swapon /dev/sdXY #交换分区 安装配置系统 安装基本系统 准备 ping -c 3 baidu.com 检查联网 vim /etc/pacman.d/mirrorlist (将合适源放到开头) timedatectl set-ntp true 安装基本系统及相关软件 pacstrap /mnt base base-devel linux linux-firmware sudo networkmanager netctl dialog dhcpcd dhcp wpa_supplicant vim base base-devel ：主要系统 linux linux-firmware ：linux内核相关 sudo ：超级用户提权工具 networkmanager ：网络管理器 netctl dialog ：无线网络连接工具 dhcpcd dhcp wpa_supplicant : 自动设置ip地址相关 vim : 文本编辑器，base中不再提供，需自行安装 配置系统 genfstab -U /mnt &gt;&gt; /mnt/etc/fstab arch-chroot /mnt visudo #注{将root ALL=(ALL) ALL 下面的 %wheel ALL=(ALL) ALL的注释去掉--》允许wheel整个组里的所有用户有权限用sudo} ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime #设置系统时区 hwclock --systohc --utc #设置时间标准 为 UTC，并调整 时间漂移: vim /etc/locale.gen #移除对应行前面的注释符号（＃）即可，建议选择帶UTF-8的項{建议移除注释 en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF -8 zh_TW.UTF-8 UTF-8} locale-gen #生成locale讯息 echo “LANG=en_US.UTF-8” &gt; /etc/locale.conf #将系统 locale 设置为en_US.UTF-8 echo “myhostname” &gt; /etc/hostname #设置myhostname为主机名 systemctl enable NetworkManager systemctl enable netctl #配置网络管理器自动启动 useradd -m -g users -G wheel username #设置username为用户名 passwd #为root设置密码 passwd username #为username设置密码 配置引导程序（二选一，推荐bootctl） bootctl bootctl是arch系列中systemd就提供的功能，能够简单快速的创建启动项，缺点是界面过于单调 bootctl install --path=/boot vim /boot/loader/loader.conf 并将内容设置为： #timeout 4 default arch 注：#timeout 4 可以保持注释状态 vim /boot/loader/entries/arch.conf 并将内容设置为： linux /vmlinuz-linux initrd /initramfs-linux.img options root=PARTUUID=yourPARTUUID rw 注：yourPARTUUID为你的PARTUUID,可以用blkid -s PARTUUID -o value /dev/sdXY &gt;&gt; /boot/loader/entries/arch.conf来将你的PARTUUID添加到你的arch.conf中再编辑，其中sdXY为你的根分区 grub grub提供了功能全面的启动菜单选项，拥有很多漂亮的主题界面，缺点是配置项太多 pacman -S dosfstools grub efibootmgr grub-install --target=x86_64-efi --efi-directory=/boot/EFI --bootloader-id=archlinux --recheck grub-mkconfig -o /boot/grub/grub.cfg 重启系统 exit umount -R /mnt reboot 到这里基本上重启就能进入到系统了，但是有时候会启动不成功，下面为一些注意事项，以便能够确保完成安装 安装完成后需要注意的事情 /boot有时候因为一些原因（可能是自己粗心大意）导致EFI没挂载上去，或者挂载上去之后安装linux内核的时候没有安装一些重要文件至/boot文件夹则需要重新安装linux内核 解决：重新安装linux内核 #在超级用户下 pacman -S linux linux-firmware impressionyang ","link":"https://impressionyang.vercel.app/post/archlinux_install_1/"},{"title":"MANJARO KDE安装配置(已换Arch Linux，此贴可能废弃)","content":"MANJARO KDE安装配置 已换Arch Linux，Manjaro文章已经不再添加更新，此文为以前所写，作为备份用,看心情更新 安装 制作启动盘 Windows下 使用rufus工具进行烧录即可。 Linux下 linux下推荐使用dd命令来进行安装，dd是一种按照文件单元进行复制的工具，可以用来进行备份，也可以用来进行刻录Linux启动盘，一般来说，近几年的图像界面的发行版里面都会安装有dd工具，命令提示如下： sudo dd if=read_in_file of=write_to_file bs=1M 提前说一下，在Linux中一切都是用文件来表示的，如在本例中的写入文件，一般来说是U盘，但是在Linux中他是已一个文件来表示的，一般为/dev/sda之类的 if：读取文件的绝对路径 of：写入文件的绝对路径 bs：写入的缓冲区？ 安装 BIOS关闭安全启动，推荐使用uEFI进行安装 进入安装环境 初始界面 硬件信息配置 选择时区 键盘设置 分区 分区相关 配置用户 配置用户信息 确认并安装 安装完成后即可重启系统 配置 系统项 软件源 官方软件源 manjaro官方给出了一个命令使得我们可以方便地更新我们的官方软件源，使用以下命令即可从官方服务器拉取相关源（能联网就可以做到）并测速，自己选择几个合适的源确定即可。 命令： sudo pacman-mirrors -i -c Chaina -m rank ArchLinuxCN源 ArchLinuxCN是Arch中文组维护的一个软件合集，里面包含了一系列的中国人使用的软件，比如WPS、网易云音乐等。 在/etc/pacman.conf文件中追加源即可 以下代码为配置清华源 sudo vi /etc/pacman.conf # 然后在按下i 进入编辑 按Ctrl+Shift+v粘贴 #粘贴内容 [archlinuxcn] SigLevel = Optional TrustedOnly Server= https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch # 按下Esc后输入:wq 退出，更新源信息并倒入GPG Key sudo pacman -S archlinuxcn-keyring&amp;&amp;sudo pacman -Syy 如果懒得管理密钥之类的东西（经常会导致archlinuxcn的软件安装失败，说是验证问题的）就把archlinuxcn的软件信任等级从Optional TrustedOnly设为TrustAll，但是如果出现问题archlinuxcn将不负任何责任。 其他的archlinuxcn源（可自行替换） 从官方那里拉取的 ## ## Arch Linux CN community repository mirrorlist ## Generated on 2019-10-01 ## ## 中国科学技术大学 (ipv4, ipv6, http, https) #Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch ## 清华大学 (ipv4, ipv6, http, https) #Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch ## Our main server (ipv4, ipv6, http, https) #Server = https://repo.archlinuxcn.org/$arch ## xTom (Hong Kong server) (Hong Kong) (ipv4, ipv6, http, https) #Server = https://mirror.xtom.com.hk/archlinuxcn/$arch ## xTom (US server) (US) (ipv4, ipv6, http, https) #Server = https://mirror.xtom.com/archlinuxcn/$arch ## Open Computing Facility, UC Berkeley (Berkeley, CA, United States) (ipv4, ipv6, http, https) #Server = https://mirrors.ocf.berkeley.edu/archlinuxcn/$arch ## 网易 (ipv4, http, https) #Server = https://mirrors.163.com/archlinux-cn/$arch ## xTom (Netherlands server) (Netherlands) (ipv4, http, https) #Server = https://mirror.xtom.nl/archlinuxcn/$arch ## SJTUG 软件源镜像服务 (ipv4, https) #Server = https://mirrors.sjtug.sjtu.edu.cn/archlinux-cn/$arch ## 腾讯云 (ipv4, https) #Server = https://mirrors.cloud.tencent.com/archlinuxcn/$arch antergos源 貌似这玩意儿废弃了？ aur源 AUR是Arch User Repository（Arch用户软件源），包含了一些不被官方源收录的软件，还有很多个人开发者开发的超酷的软件等你下载，但是aur不归pacman管理，所以要使用其他的包管理软件，如yay，yaourt(已停止维护)等。 设置 aur 源 修改 /etc/yaourtrc，去掉 # AURURL 的注释，修改为 AURURL=&quot;https://aur.tuna.tsinghua.edu.cn&quot; iBus拼音输入法 为什么用iBUs？ iBUs支持使用与KDE Plasma相近的输入法面板主题，使用iBus输入法可以让输入法和系统主题更有统一感。 安装 安装iBus sudo pacman -S ibus 安装iBus拼音输入法 sudo pacman -S ibus-sunpinyin #这个输入法我个人比较喜欢，也可以安装google的拼音输入法 安装iBus Qt支持 yay -S ibus-qt 配置iBus 需要在~/.bashrc下添加 export GTK_IM_MODULE=ibus export XMODIFIERS=@im=ibus export QT_IM_MODULE=ibus 在~/.xprofile和~/.xinitrc文末后添加 export GTK_IM_MODULE=ibus export XMODIFIERS=@im=ibus export QT_IM_MODULE=ibus ibus-daemon -drx 启动iBus Deamon守护进程 控制台输入 ibus-setup 之后自己进行输入法的配置就行 配置输入法面板的主题 输入法面板的主题需要在可见面板中添加一个小部件输入法面板，之后注销重新登陆即可现实和系统主题一致的输入法面板主题了。 双显卡显卡驱动方案 安装驱动及bbswitch 安装时记得选择和自己内核版本一致的nvidia显卡驱动，一般来说越新越好 sudo pacman -S nvidia bbswitch 切换方案 本切换方案采用archwiki中的解决方法 yay -S optimus-manager-qt-kde 安装好之后记得使optimus-manager-qt-kde能够登陆自启动 ** 注意 ** 安装后阿可能有打不开steam的情况，记得安装libGL相关的包，一般是缺失例如lib32-nvidia-440xx-utils的包，记得选择和自己安装的相关的包哦 触控板 由于xf86-input-synaptics驱动已经停止了维护工作， - 所以manjaro官方把触控板驱动换成了支持wayland的libinput，但是默认情况下xorg（我目前用的）中的plasma桌面的设置中触控板管理工具无法完成libinput触控板驱动的实时配置，所以根据arch wiki的指示下安装了支持实时配置libinput的图形化工具kcm-pointing-devices-git（aur中,其他桌面就智者见智吧）， 安装后即可，命令 #没有aur工具的话就先安装yay或者yaourt sudo pacman -S yay #然后再安装lininput yay -S kcm-pointing-devices-git 即可重新完成对触控板的特性支持，包括轻触，按键模拟等特性 然后自己配置就行。 impressionyang ","link":"https://impressionyang.vercel.app/post/manjaro-install-config/"},{"title":"置顶公告","content":"访问本站方法 我的博客即将同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=1qmqj8k4htt5u 本站一共有三种方法可以访问到 外国通道（github）：impressionyang.github.io 国内通道（gitee）： impressionyang.gitee.io 国内通道 （西部数码）：impressionyang.top 由于西部数码使用的是虚拟主机，而更新插件ftpsync有毛病了，所以更新全靠手动，更新会晚很多，请尽量使用git通道 使用哪种方法进行访问就看你自己的选择了。 主要发布一些编程方法与技巧，还有一些Linux操作系统的技术，也有一些日常的吐嘈吧可能。 发布 此为第一次发布内容 首次使用了git page+hexo搭建博客 用于将以前的个人文档上传整理 添加一些新的知识 文档大概分类 categories 分为三种分类 日常类,categories=daily 编程类,categories=program 技巧类,categories=skill 培训学习类，catagories=learn tag 下面是主标签，每个帖子会发布多标签，一般为主标签+具体标签 第一个标签（主标签）就是帖子的分类 日常类,tag=daily,... 编程类,tag=program,... 技巧类,tag=skill,... 培训学习类，tag=learn,华清远见farsight 具体分类 日常 技术 技巧 记事(text) 编程语言(具体的语言) 便捷操作(具体的操作) ... 编程工具(具体的工具) 操作系统日常(Linux)(具体操作) ... ... 文章查找 直接搜索关键词 在首页可以点击博客网站的顶部的搜索按钮进行关键词搜索 归档 在任意页面博客站顶部的文章-&gt;归档进行上传日期为索引的文章检索 标签和分类 在任意页面博客站顶部的文章-&gt;分类/标签进行以 分类/标签 为索引的文章检索 impressionyang ","link":"https://impressionyang.vercel.app/post/first-begin/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://impressionyang.vercel.app/post/hello-gridea/"}]}